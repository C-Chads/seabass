<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>153</title>
    <script></script>
  </head>
  <body>
    <!-- Content -->
    <center>
    <h1>
        SEABASS- An Introduction
    </h1>
    <hr>
    <img src="logo.png" alt="logo" style="width:100%">
    </center>
    <hr>
    <!-- Index-->
    <div style="margin-left:10%;">
        <a href="doc/CBAS_manual.html">Tool Manual</a><br>
        <a href="doc/SEABASS_Language_Spec.html">Language Spec</a><br>
        <a href="doc/style.html">Style Guidelines</a><br>
        <a href="doc/C_FFI.html">Calling C from Seabass (or vice versa)</a><br>
    </div>
    <hr>
    <div style="margin-left:10%;">
        <a href="#dedicatory">Dedicatory</a><br>
        <a href="#fallible">Notice of Fallibility</a><br>
        <a href="#prereq">Prerequisites</a><br>
        <a href="#terminology">Terminology</a><br>
        <a href="#whatis">What is Seabass?</a><br>
        <a href="#basicsyntaxc">Basic Syntax versus C</a><br>
        <a href="#codegen">codegen</a><br>
        <a href="#codegenmain">codegen_main</a><br>
        <a href="#parsehooks">parsehooks</a><br>
        <a href="#syntaxsemantics">Syntax Semantics</a><br>
        <a href="#oop">Object Oriented Programming</a><br>
        <a href="#pointers">Pointer Semantics</a><br>
        <a href="#tailcall">Tail Calls</a><br>
        <a href="#typedecl">Types</a><br>
        <a href="#typealiases">Type Alias List</a><br>
        <a href="#keywords">Keyword List</a><br>
        <a href="#gotolabels">Labels</a><br>
        <a href="#switch">Switch Statement</a><br>
        <a href="#datastmt">Data Statement</a><br>
        <a href="#qualifiers">Symbol Qualifiers</a><br>
        <a href="#alignment">Alignment</a><br>
        <a href="#memberptr">The Member Pointer Operator</a><br>
        <a href="#getptr">getglobalptr and getfnptr</a><br>
        <a href="#callfnptr">callfnptr</a><br>
        <a href="#streq">streq and strneq</a><br>
        <a href="#finale">Fin</a><br>
        <a href="#blessing">Blessing</a><br>
        <a href="#license">License</a><br>
    </div>
    <hr>

    <p>Welcome, conquerors, to the Seabass Metaprogramming language! This html document should serve as an introduction.<br><i>Saying, Blessed are they whose iniquities are forgiven, and whose sins are covered.</i> - Romans 4:7</p>
    <hr>
    <center>
    <h3>All Glory to the Lord Jesus Christ, who is, and who was, and who is to come, for ever. Amen.</h3>
    </center>
    <hr>
    <center>
    <h2 id="dedicatory">Dedicatory</h2>
    </center>
    <hr>
    <p>"Hear, O LORD, when I cry with my voice: have mercy also upon me, and answer me."</p>
    <p>-Ps 27:7</p>
    <hr>
    <p>Seabass, as an idea, a programming language, a working program, and a concept, are all undeserved gifts I have been given. God put it into my hand to build them. For creating heaven and earth in six days, to freely giving us eternal life, to the simple joy of breathing, let all thanks and praise be directed to God our Father and our Lord Jesus Christ. Amen.</p>

        <hr>
    <center>
    <h2 id="fallible">Notice of Fallibility</h2>
    </center>
    <hr>
    <p>The Seabass programming language, the original C99 implementation, its original standard library, and all of its documentation were authored by a single person. Expect to find mistakes, errors, and omissions.</p>
    <hr>
    <center>
    <h2 id="prereq">Prerequisites</h2>
    </center>
    <hr>
    <p>This documentation is written with the belief that the reader....</p>
    <ol>
        <li>Has a background in Computer Programming, i.e. not a newcomer</li>
        <li>Is passionate about; interested in Computer Programming</li>
        <li>Is an eager independent learner</li>
        <li>Is familiar with at least one systems-level Programming Language- hopefully C</li>
        <li>Can read snippets of C with short explanations</li>
        <li>Can use a search engine to understand terms they are not familiar with</li>
        <li>Is willing to thoroughly read documentation, with backtracking.</li>
    </ol>
    <p>This documentation uses many pieces of terminology which you are likely to be unfamiliar with...</p>
    <hr>
    <center>
    <h2 id="terminology">Terminology</h2>
    </center>
    <hr>
    <p>Note that Italicized terms are considered "standard", meaning that more information should be easily attainable from independent study on the web.</p>
    <ul>
        <li><b>Seabass</b><br>
            <ol>
            <li>The programming language documented by this html document.</li>
            <li>The project surrounding that language</li>
            </ol>
        </li>
        <li><i><b>P***X</b></i><br>
            An old standard for how operating systems should be designed.<br>
            [Systems programming lingo]
        </li>
        <li><i><b>64 bit</b></i><br>
            <ol>
                <li>Having a 64 bit address space (i.e. "cbas was written for 64 bit byte-addressable P***X systems")</li>
                <li>Capable of handling 64 bit integer arithmetic in a single operation.</li>
            </ol>
            [Systems programming lingo]
        </li>
        <li><i><b>Byte-addressable</b></i><br>
            Of a computer platform, the ability to address memory by 8-bit chunks. This is as opposed to non-byte-addressable systems, such as the PDP-12, which has memory addressed by 12-bit chunks.<br>
            [Systems programming lingo]
        </li>
        <li><b>CBAS / cbas</b><br>
            The tool which works with Seabass programs, originally written
            in C99 for 64 bit byte-addressable P***X machines.
        </li>
        <li><i><b>Compiler</b></i><br>
            A piece of code which turns one computer language into another.<br>
            [Programming language lingo]
        </li>
        <li><i><b>AST</b></i><br>
            Internal representation of a program's source code, or a portion thereof, which represents its grammatic structure.<br>[Programming language lingo]
        </li>
        <li><i><b>Token</b></i><br>
            Small piece of source code text.<br>
            [Programming language lingo]
        </li>
        <li><i><b>Parser</b></i><br>
            A piece of computer code which discerns the structure of a computer program from its source code and constructs an AST.<br>
            [Programming language lingo]
        </li>
        <li><i><b>Identifier</b></i><br>
            Name for an object in a computer program. Seabass uses C rules for identifiers.<br>
            [Programming language lingo]
        </li>
        <li><i><b>Keyword</b></i><br>
            Reserved, special sequence of english characters, underscores, and decimal digits. May not start with a digit.<br>[Programming language lingo]
        </li>
        <li><b>codegen</b><br>
            short for "code generation". Adjective. Keyword in the SEABASS language.<br>
            Applied to a function, method, or variable: that function/method/variable
            "exists" only during the execution of the cbas tool.
        </li>
        <li><b>Target</b><br>
            The computer language which a program desires to be compiled for.<br>
            In Seabass, any code which is not "codegen" is considered "target", meaning
            its purpose is to be translated into some other language.
        </li>
        <li><i><b>Domain-Specific Language</b></i><br>
            A computer language designed for a niche in programming, rather than
            general-purpose use.<br>[Programming language lingo]
        </li>
        <li><i><b>Translation unit</b></i><br>
            All the source code connected to a single .cbas file, i.e.
            the main file and everything you `#include` in.<br>[Programming language lingo]
        </li>
        <li><i><b>Recursive descent</b></i><br>
            A scheme for writing parsers.<br>[Programming language lingo]
        </li>
        <li><i><b>Lvalue</b></i><br>
            Assignable and readable value in an expression. When a variable's name is used in an expression, it is an <i>lvalue</i> there.<br>[Programming language lingo]
        </li>
        <li><b>Symbol</b><br>
            Root nodes for objects in Seabass's AST. I.e., the parsed translation unit is comprised of functions, class/struct declarations, global variables, and data statements.
        </li>

    </ul>
    <hr>
    <center>
    <h2 id="whatis">What is Seabass?</h2>
    </center>
    <hr>
    <p>Seabass is a public domain, self-retargeting, self-extending, self-modifying metaprogramming language, and general purpose metaprogramming tool.</p>
    <p>Allow me to elaborate:</p>
    <ul>
        <li>
            <h3>Public Domain</h3>
            <p>Seabass (language, tool, documentation, libraries, and artwork) are all released to you under the CC0 license. No attribution is required and no license files are needed. These are my gifts to you in perpetuity, so long as you can retain them. May your joy be full.</p>
        </li>
        <li>
            <h3>Language</h3>
            <p>Seabass is a programming language- a written language for expressing computer programs.</p>
        </li>        
        <li>
            <h3>Tool</h3>
            <p>Seabass is an executable computer program (cbas) which can be compiled for 64 bit P***X-compatible systems with byte-addressable memory. It is used for working with programs written in the Seabass language. To distinguish between the Language and the Tool, the language shall be called "Seabass" and the tool shall be called "cbas" or "CBAS" (all pronounced "SEE BASS"). Tools other than this tool shall not be called "cbas" or "CBAS" but instead shall be referred to by some other name (i.e. "the Seabass Standard Metaprogramming Library").</p>
        </li>
        <li>
            <h3>Metaprogramming</h3>
            <p>Seabass contains special language constructs for writing code which writes code, or manipulates pre-existing code. This is designed to allow the user to implement their own abstractions and use them in their source code. It's even possible to implement entire new compiled languages.</p>
        </li>
        <li>
            <h3>Self-retargeting</h3>
            <p>Seabass allows the user to define a special function called "codegen_main" which is responsible for generating "target code". This allows programmers to define how their code should be compiled.</p>
        </li>
        <li>
            <h3>Self-extending</h3>
            <p>Seabass allows you to write code which effectively extends the capabilities of the compiler. This can be done within the translation unit and does not require modifying the cbas tool. This code is referred to as "codegen".</p>
        </li>

        <li>
            <h3>Self-modifying</h3>
            <p>codegen code is given virtually unrestricted access to the internals of the compiler. It can modify the tokenized source code which has yet to be parsed, or even manipulate the AST of code which has already been parsed.</p>
        </li>
    </ul>
    <hr>
    <center>
    <h2 id="basicsyntaxc">Basic Syntax versus C</h2>
    </center>
    <hr>
    <p>Seabass's base-level language was designed to be a simplification, enhancement, and general improvement of C. In order to convey the basics of the syntax of Seabass, here is a simple fibonacci number program in both languages:</p>
    <pre><code>
    /*C program*/
    #include &ltstdio.h&gt
    #include &ltstdlib.h&gt
    
    void mutoa(char* dest, unsigned int value);
    unsigned matou(char* in);
    
    static inline unsigned int fib(unsigned n){
        if(n < 2)
            return 1;
        unsigned int a = 1;
        unsigned int b = 1;
        unsigned int c = 1;
        n = n - 2;
        while(n){
            c = a + b;
            a = b;
            b = c;
            n--;
        }
        return c;
    }
    
    int main(int argc, char** argv){
        if(argc < 2){
            puts("Usage: fib 13");
            exit(1);
        }
        puts("Welcome to the fibonacci number calculator!");
        char buf[50];
        unsigned qq = matou(argv[1]);
        puts("You asked for the fibonacci number...");
        mutoa(buf, qq);
        puts(buf);
        puts("That fibonacci number is:");
        mutoa(buf, fib(qq));
        puts(buf);
        return 0;
    }
    
    unsigned matou(char* in){
        unsigned retval = 0;
        while(
            (*in >= '0') &&
            (*in <= '9')
        ){
            retval *= 10;
            retval += *in - '0';
            in++;
        }
        return retval;
    }
    
    void mutoa(char* dest, unsigned value){
        if(value == 0){
            dest[0] = '0';
            dest[1] = 0;
            return;
        }
        {
            unsigned pow;
            pow = 1;
            while(value/pow >= 10){
                pow = pow * 10;
            }
            while(pow){
                unsigned temp;
                temp = value / pow;
                *dest = (temp + ('0')); dest++;
                value = value - temp * pow;
                pow = pow / 10;
            }
        }
        ending:;
        *dest = 0;
    }
    </code></pre>
    <p>Here is an equivalent program in Seabass:</p>
    <pre><code>
    /*Seabass program*/
    #include &lttoc_native_user&gt
    
    @wksht prnt [
        [
            @pprint [println mutoa ARG1]
        ][
            ARG1
        ]
    ]
    
    fn predecl mutoa(char* dest, uint value);
    fn predecl matou(char* in)->uint;
    
    fn inline fib(uint n)->uint:
        if(n < 2)
            return 1;
        end
        uint a=1
        uint b=1
        uint c=1;
        n = n-2
        while(n)
            c = a + b;
            a = b;
            b = c;
            n--
        end
        return c
    end
    
    fn pub main(int argc, schar** argv)->int:
        if(argc < 2)
            @prnt[
                /       "Usage: fib 13"
            ]
            sys_exit(1);
        end
        println("Welcome to the fibonacci number calculator!");
        uint qq = matou((char*)argv[1]);
        @prnt[
            /       "You asked for the fibonacci number..."
            /int    (qq)
            /       "That fibonacci number is:"
            /int    (fib(qq))
        ]
        return 0;
    end
    
    fn codegen codegen_main():
        cg_emitC(SEABASS_STDLIB_PREFIX);
    end
    
    fn matou(char* in)->uint:
        uint retval = 0;
        while(
            (in[0] >= '0') && 
            (in[0] <= '9')
        )
            retval = retval * 10;
            retval = retval + (in[0]-'0');
            in++
        end
        return retval;
    end
    
    fn mutoa(char* dest, uint value):
        if(value == 0)
            dest[0] = '0';
            dest[1] = 0;
            return 
        end
        if(1)
            uint pow
            pow = 1;
            while(value/pow >= 10)
                pow = pow * 10; 
            end
            while(pow)
                uint temp
                temp = value/pow;
                dest[0] = (temp + ('0')); dest++;
                value = value - temp * pow;
                pow = pow / 10
            end
        end
        :ending
        dest[0] = 0
    end
    </code></pre>

    <p>This alone should give you a rough picture of how Seabass "behaves" relative
    to C. Please examine the two programs carefully. I expect you have discerned the following:</p>
    <ol>
        <li>C delimits scopes with brackets, while seabass is more freeform- a scope opens immediately after constructs such as <code>if</code> and <code>while</code>.</li>
        <li>Statements in Seabass do not always require a terminating semicolon.</li>
        <li>in addition to "main" the Seabass program also defines "codegen_main"</li>
        <li>Pointer dereferencing in C can be done with <code>*</code> but in Seabass it is only done with square brackets.</li>
        <li>Return values in seabass are written after the parentheses-delimited function argument list.</li>
        <li>Types in seabass are written slightly differently.</li>
        <li>The seabass program includes several unusual sequences starting with the '@' sign.</li>
    </ol>
    <p>However, most important of all, you should notice that the seabass code is mostly identical in structure
    and semantics to the C code. Seabass is designed to be easy to pick up for C programmers.</p>
    <h3>The @ sign...</h3>
    <p>In Seabass, this is known as the <b>metaprogramming operator</b>. it is used to invoke code at compile time. In this case, it is used to implement the custom syntaxes `wksht` and `pprint`, and in the code provided, we define a new derived syntax, `prnt`.</p>
    <p>The exact nature and semantics of how this all works will be discussed later. All you need to understand right now is that this is the first and most important part of what makes Seabass different from C- the metaprogramming operator. It is the most significant new feature Seabass has over C. Almost all other new features are eclipsed by it.</p>
    <h3>Are they just macros?</h3>
    <p>The word "macro" is used with reckless abandon by many different programming languages. Compilers themselves could be envisioned as giant macros using the definitions used by some programming languages.</p>
    <p>The short answer is <b>No</b>, however <b>the metaprogramming operator is used to implement macros.</b></p>
    <p>I define a macro as "Any simple text replacement scheme which contains minimal or non-existant semantic or syntax rules".</p>
    <p>The `@prnt` operation is a macro, created by invoking `@wksht`, wrapping the `@pprint` Domain-Specific Language.</p>
    <p>The use of the metaprogramming operator will be explained later. We must discuss some pre-requisite concepts first.</p>
    <hr>
    <center>
    <h2 id="codegen">codegen</h2>
    </center>
    <hr>
    <p>Seabass allows you to define functions and variables which exist exclusively at compiletime, i.e., while the `cbas` tool is running. <b>They do not exist in the final compiled program.</b></p>
    <p>These "symbols" are annotated as such using the `codegen` keyword.</p>
    <p>codegen functions may access special `builtin` functions of the `cbas` tool, giving it access to the internals of the compiler, the filesystem, compiletime memory allocation, and etcetera.</p>
    <p>codegen functions are invoked from any of the following:</p>
    <ol>
        <li>Called from another codegen function</li>
        <li>a "parsehook invocation" (using the metaprogramming operator- @)</li>
        <li>the "__cbas_run_fn" directive.</li>
        <li>After parsing is finished, `codegen_main` is executed.</li>
    </ol>
    <p>All of this happens during execution of `cbas` on a translation unit.</p>
    
    <hr>
    <center>
    <h2 id="codegenmain">codegen_main</h2>
    </center>
    <hr>
    <p>As mentioned <a href="#whatis">before</a> , Seabass is self-retargeting. It allows you to define a function which is responsible for generating the "output" of the compiler.</p>
    <p>In the fibonacci number program from the <a href="#basicsyntaxc">previous section</a>, it was used to generate C code. This C code would then be compiled with a C compiler to generate an executable binary.</p>
    <p>codegen_main is only special in that the `cbas` tool will attempt to find it inside the translation unit after parsing has finished. If it cannot find it, it will print out the parsed AST and then exit.</p>
    <p>In principle, the codegen_main function can generate arbitrary output. It is fully programmable.</p>
    <p>If you should desire to use Seabass as a scripting language, it is possible to write entire programs purely within the confines of `codegen` code, and use the `cbas` tool like a script interpreter. This functionality was used to develop and debug the original implementation.</p>
    <hr>
    <center>
    <h2 id="parsehooks">parsehooks</h2>
    </center>
    <hr>
    <p><i>We are now ready to discuss what the @ sign does.</i></p>
    <p>In seabass, you can write special codegen functions which can be invoked with the metaprogramming operator. Here is how you declare and use one:</p>
    <pre><code>
    proc codegen parsehook_dostuff():
        __builtin_puts("Hello, World!");
    end
    //invocation...
    @dostuff
    </code></pre>
    <p><i>(Note that 'proc' is just an alias for 'fn')</i></p>
    <p>When the parser sees an @ sign followed by an identifier, it looks for a codegen function with that name prefixed by 'parsehook_'. This function is then immediately called. This function can then use builtin functions such as __builtin_peek() to access the tokenized source code of the program and manipulate it. This functionality was used to implement `@wksht` and `@pprint` from <a href="#basicsyntaxc">before</a>.</p>
    <hr>
    <center>
    <h2 id="syntaxsemantics">Syntax Semantics</h2>
    </center>
    <hr>
    <p>You now understand the basics of what makes Seabass unique. 
    However, in order to actually get started programming, you 
    need to understand some of the other features and details 
    of the language.</p>
    <hr>
    <center>
    <h2 id="oop">Object Oriented Programming</h2>
    </center>
    <hr>
    <p>For convenience, Seabass has several features from Object Oriented programming:</p>
    <ol>
        <li>the `class` keyword as an alias for `struct`.</li>
        <li>methods- functions invoked on a struct/class which are specific to that class/struct. 'this' is passed as a secret first argument- a pointer to the object the method was invoked on.</li>
        <li>Automatic constructors and destructors- Functions which are invoked on a struct when it first appears in a scope, and when it disappears.</li>
    </ol>
    <p>Here is a small example program (using entirely codegen code) which demonstrates object oriented programming in Seabass:</p>
    <pre><code>
    /*
        Small program to demonstrate object oriented programming in Seabass.
    */
    
    class myClass
        noexport
        int a
        char* b
    end
    
    codegen int a = 25;
    
    method codegen myClass.ctor():
        this.a = a++;
        char[500] buf
        __builtin_itoa(buf, this.a);
        this.b = __builtin_strdup(buf);
        __builtin_puts("I have been constructed! My string is...");
        __builtin_puts(this.b);
    end
    
    method codegen myClass.dtor():
        __builtin_puts("Goodbye! My string was...");
        __builtin_puts(this.b);
        __builtin_free(this.b);
        a--
    end
    
    method codegen myClass.print():
        __builtin_puts(this.b)
    end
    
    fn codegen codegen_main():
    
        i64 i
        for(i = 0, i < 10; i++)
            myClass qq
            myClass qq2
            myClass qq3
            myClass qq4
            qq3.print()
            if(i == 3) continue end
            qq2.print()
        end
        
        if(1)
            //demo move...
            myClass qq
            myClass qq2
            __builtin_free(qq.b); //ensure we don't leak memory...
            qq := qq2;
            qq2.b = __builtin_strdup("I seem to have lost my old string...");
            qq:print();
            qq2.print();
        end
        return	
    end
    </code></pre>
    <p>As you can see, `.ctor()` and `.dtor()` are methods on the `myClass` type. The `ctor` method is invoked at instantiation, and the `dtor` method is invoked when the object is destroyed. `continue` properly causes objects within a loop body to be destroyed.</p>
    <p>.ctor() and .dtor() methods are NOT automatically called under these circumstances:</p>
    <ol>
        <li>When an array of objects is declared</li>
        <li>When objects are declared at global scope</li>
        <li>When a pointer to an object is declared</li>
        <li>When an object is inside of another object</li>
    </ol>
    <p>You must be especially careful of 4- Seabass will <b>not</b> automatically write constructors and destructors for you, nor automatically insert invocations of member object constructors/destructors. You must write the constructors and destructors for your objects yourself, constructing and destroying member objects where appropriate.</p>
    <p><i>[Note, of course, that because Seabass is a metaprogramming language, it is possible to write languages within Seabass that do not have these limitations...]</i></p>
    <p>Also note that seabass does not have any of the following from object oriented programming:</p>
    <ol>
        <li>Inheritance</li>
        <li>Virtual methods</li>
        <li>Operator overloading</li>
    </ol>
    <p>It <i>does</i> have move semantics. There is a dedicated "move" operator, <code>:=</code> which copies one pointed-to object into another.</p>
    <p>Other errata:</p>
    <ul>
        <li>method invocation syntax may be done lua-style (myClass:myMethod()) or C++ style (myClass.myMethod())</li>
        <li>Objects live for the entire duration of their scope, not just from where they were
        declared in their scope. That is to say- an object's constructor is called <i>before its declaration</i>,
        at the beginning of the scope.</li>
    </ul>
    <hr>
    <center>
    <h2 id="pointers">Pointer Semantics</h2>
    </center>
    <hr>
    <p>The syntax of Seabass differs from C most in its usage of pointers. Note the following:</p>
    <ol>
        <li>It is not possible to get the address of local primitive variables. You may not use the `&` operator to take the address of a variable. Taking the address of global variables is done with `getglobalptr`.</li>
        <li>There are no function pointers in the type system- all function pointers are `byte*`. They are obtained with `getfnptr` and used with `callfnptr`.</li>
        <li>Structs never appear by-value in an expression.</li>
        <li>Indexing an array of pointer-to-struct will yield a pointer-to-struct rather than an lvalue struct.</li>
        <li>Just like C, arrays decay into pointers in an expression.</li>
        <li>Seabass has a dedicated `memcpy` operator, called the `move` operator, <code>:=</code>.</li>
        <li>Seabass has two dedicated C-string comparison operators, `streq` and `strneq`.</li>
    </ol>
    <p>For C programmers, this means all of the following:</p>
    <ol>
        <li>In order to pass a pointer to a primitive variable (such as passing int* len into a buffer-filling function) you should declare an array of length one. I.e. in C you would do this....
        <pre><code>
        void myfunction(char* buf, int* lenout);
        
        /*usage...*/
        int lenout;
        char buf[256];
        myfunction(buf, &lenout);
        </code></pre>
        But you would do this in Seabass:
        <pre><code>
        fn myfunction(char* buf, int* lenout);
        
        //usage...
        int[1] lenout;
        char[256] buf;
        myfunction(buf, lenout);
        </code></pre>
        (please also note that seabass places array length <i><b>next to the type</b></i> and not next to the variable name).
        </li>
        <li>Passing structs by-value is not possible in Seabass. 
        If you want to pass an object into a function in seabass, 
        you pass a pointer to that object. 
        That function can then make a separate copy if it so desires. 
        <i>Please note that if pass-by-value is performance-critical 
        to your application, it can still be achieved with inline target code.</i>.
        </li>
        <li>Use of <code>strcmp(a,b)==0</code> is outmoded in Seabass. 
        You do <code>a streq b</code>.
        </li>
        <li>If you have an array of structs like so...
        <pre><code>
        struct mystruct
            mystruct* c
            char[1<<6] name
            int a
            i32 b
        end
        mystruct[12*50/2] myarray;
        </code></pre>
        Then <code>myarray[27]</code> is semantically equivalent to <code>(myarray + 27)</code>. A struct type <i>never</i> appears by-value in an expression.

        </li>
        <li>
        Function pointer syntax has been changed. An example:
        <pre><code>
        //function whose pointer we take...
        fn myfunction(int a, char* text)->float;
        
        //this function's prototype is used....
        fn noexport template_function(int q, char* t)->float;
        
        //retrieve a pointer to `myfunction`
        byte* mypointer = getfnptr(myfunction);
        
        //call the function...
        float x = callfnptr[template_function](mypointer)(3, "Hello World!");
        </code></pre>
        </li>
        <li>Assignment between structs is done using the `move` operator:
        <pre><code>
        struct mystruct
            mystruct* c
            char[1<<6] name
            int a
            i32 b
        end
        
        mystruct a
        mystruct b
        
        //later....
        
        //a = b; //ERROR!
        a := b; //correct
        </code></pre>
        The move operator can of course be used on any pointers of compatible type, not just pointers to structs...
        <pre><code>
        //'array of pointer to int'
        int*[530] a;
        //'pointer to int'
        int* b;
        
        
        //later...
        
        /*
        *copy the object pointed to by b into the
        *object pointed to by the 20th element of a
        */
        a[20] := b;
        </code></pre>
        
        </li>
    </ol>
    <hr>
    <center>
    <h2 id="tailcall">Tail Calls</h2>
    </center>
    <hr>
    <p>Seabass allows a function to "tail call" another- i.e., it will 'jump' to that function.</p>
    <p>This is particularly useful for implementing some kinds of algorithms.</p>
    <p>Tail calls are only valid between two functions with the same prototype. I.e.- this is valid-</p>
    <pre><code>
        fn tailtome(i32 a, byte b)->f32;
        fn myfunction(int a, char b)->float:
            tail tailtome //prototype is identical (i32,u8)->f32
        end
    </code></pre>
    <p>But this is not:</p>
    <pre><code>
        fn tailtome(i32 a, byte b)->f32;
        fn myfunction2(int a, int b)->int:
            tail tailtome //ERROR: prototype does not match! (i32,i32)->i32 != (i32,u8)->f32
        end
    </code></pre>
    <p>because myfunction2 does not have an identical prototype to `tailtome`.</p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <hr>
    <center>
    <h2 id="typedecl">Types</h2>
    </center>
    <hr>
    <p>In seabass, a type always follows this pattern:</p>
    <p><code>typename********[constexpr]</code></p>
    <p>Namely, a single identifier ('typename') followed by zero or more stars and an optional 'bracketed portion' denoting an array length.</p>
    <p>Type declarations are used in the following locations:</p>
    <ol>
        <li>To declare variables:
        <pre><code>
        int my_int;
        int* my_pointer_toint;
        int[50] my_array_of_50_ints;
        int*[10*5] my_array_of_50_pointers_to_ints;
        mystruct my_struct_variable;
        mystruct[5] my_array_of_5_struct_variables;
        mystruct******[1<<13] Can_you_guess;
        </code></pre>

        </li>
        <li>In sizeof().
        <pre><code>
        sizeof(mystruct***[50])
        </code></pre>
        <i>Note that this is the only valid use of sizeof. You may not put variable names or expressions inside of sizeof.</i>
        </li>
        <li>In the data statement. Note that you may not declare a data statement of pointers, arrays, or structs.
            <pre><code>
        data codegen int myintegers 5,3,1<<2;
            </code></pre>
            <i>The data statement will be discussed in more detail later.</i>
        </li>
        <li>In the prototype of functions and methods.
            <pre><code>
        fn myfunction(int a, char* b)->mystruct;
            </code></pre>        
            Note the following "gotchas":
            <ul>
                <li>All references to non-pointer structs will be converted to pointer-to-struct. I.e., the following declarations are identical:<br><br>
                    <code>procedure myproc(mystruct a)->mystruct;</code><br>
                    <code>function myproc(mystruct* a)->mystruct;</code><br>
                    <code>func myproc(mystruct a)->mystruct*;</code><br>
                    <code>proc myproc(mystruct* a)->mystruct*;</code><br>
                    <br>
                    <br>
                </li>
                <li>You may not pass an array into a function or return it. These are syntax errors:
                    <br>
                    <br>
                    <code>proc myproc(int[50] a)->int;</code><br>
                    <code>fn myproc(int a)->int[50];</code><br>
                    <br>
                    <br>
                </li>
            </ul>
        </li>
    </ol>
    <hr>
    <center>
    <h2 id="typealiases">Type Alias List</h2>
    </center>
    <hr>
    <p>Here is a list of all primitive types, and their aliases.</p>
    <pre><code>
        u8 - char - uchar - byte - ubyte
        i8 - schar - sbyte
        u16 - ushort
        i16 - short - sshort
        u32 - uint - ulong
        i32 - int - sint - long - slong
        u64 - ullong - qword - uqword - uptr
        i64 - llong - sllong - sqword
        f32 - float
        f64 - double
    </code></pre>
    <p><i>Note that pointers are also considered primitive.</i></p>
    <p>structs, classes, and unions are *not* considered primitive.</p>
    <p>Note that `void`, while it exists in the type system, <i>does not have a keyword in the language</i>. Seabass uses `byte*` instead of `void*`.</p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <hr>
    <center>
    <h2 id="keywords">Keyword List</h2>
    </center>
    <hr>
    <p>Please note that aliases are listed on the same line separated by hyphens.</p>
    <h3>Keywords</h3>
    <pre><code>
    fn - function - func - procedure - proc
    cast
    u8 - char - uchar - byte - ubyte
    i8 - schar - sbyte
    u16 - ushort
    i16 - short - sshort
    u32 - uint - ulong
    i32 - int - sint - long - slong
    u64 - ullong - qword - uqword - uptr
    i64 - llong - sllong - sqword
    f32 - float
    f64 - double
    noexport
    break
    data
    string
    end
    continue
    if
    elif - elseif
    else
    while
    for
    goto - jump
    switch
    return
    tail
    sizeof
    static
    pub - public
    predecl
    struct - class
    union
    method
    codegen
    constexpri
    constexprf
    pure
    inline
    atomic
    volatile
    getfnptr
    callfnptr
    getglobalptr
    asm
    </code></pre>
    <h3>Operators</h3>
    <p>Please note that aliases are listed on the same line separated by commas.</p>
    <pre><code>
    ++
    --
    :=
    :
    <=
    <
    >=
    >
    != , neq
    == , === , eq
    ->
    .&
    &
    &&
    |
    ||
    >>
    <<
    ~
    !
    .
    &
    *
    +
    -
    /
    %
    ^
    |
    ? //unused
    =
    @
    streq
    strneq
    </code></pre>
    <p><i>Note that comma is *NOT* an operator.</i></p>
    <h3>Special Reserved Characters and sequences</h3>
    <pre><code>
    "string literals"
    '\n'
    #
    #include ""
    #include <>
    #define
    #undef
    #guard
    ,
    ;
    </code></pre>
    <h3>String literal and character literal escape sequences</h3>
    <pre><code>
    \a - ASCII 0x7
    \b - ASCII 0x8
    \e - ASCII 0x1B
    \f - ASCII 0xC
    \n - ASCII 0xA
    \r - ASCII 0xD
    \t - ASCII 0x9
    \v - ASCII 0xB
    //the following escape sequences simply emit the second character.
    \\ - ASCII 0x5C
    \' - ASCII 0x27
    \" - ASCII 0x22
    \? - ASCII 0x3F
    </code></pre>
    <hr>
    <center>
    <h2 id="gotolabels">Labels</h2>
    </center>
    <hr>
    <p>Seabass declares goto labels with a colon at the beginning rather than the end:</p>
    <p><code>:mylabel</code></p>
    <p><code>:mylabel2</code></p>
    <p><code>:my_really_long_labelname</code></p>
    <p>They are used by `goto`/`jump` and `switch`.</p>
    <p><code>goto my_really_long_labelname</code></p>
    <p><code>jump my_really_long_labelname</code></p>
    <p><code>switch(1+1) mylabel mylabel2 my_really_long_labelname;</code></p>
    <p>Note that goto may not enter a scope, It can only jump within its own scope or a parent scope.</p>
    <pre><code>
    goto mylabel1 //ERROR
    goto mylabel2 //ERROR
    goto mylabel2_5 //ERROR
    goto mylabel3 //ERROR
    goto mylabel4 //OK
    if(1)
        jump mylabel1 //OK

        :mylabel1

        jump mylabel3 //OK
        goto mylabel4 //OK
        goto mylabel2 //ERROR
        jump mylabel2_5 //ERROR
        if(1)
            :mylabel2
            goto mylabel1   //OK
            goto mylabel2   //OK
            jump mylabel3   //OK
            goto mylabel4   //OK
            goto mylabel2_5 //ERROR
        elif(1)
            goto mylabel1   //OK
            goto mylabel2   //ERROR
            goto mylabel2_5 //OK
            jump mylabel3   //OK
            goto mylabel4   //OK
            :mylabel2_5
            jump mylabel1   //OK
            jump mylabel2   //ERROR
            jump mylabel2_5 //OK
            jump mylabel3   //OK
            goto mylabel4   //OK
        end
        :mylabel3
        jump mylabel1 //OK
        jump mylabel2 //ERROR
        jump mylabel2_5 //ERROR
        goto mylabel3 //OK
        jump mylabel4 //OK
    end
    :mylabel4
    </code></pre>
    <p></p>
    <p></p>
    <p></p>

    <hr>
    <center>
    <h2 id="switch">Switch Statement</h2>
    </center>
    <hr>
    <p>Seabass has a switch statement that works very differently from C. It is a pure unchecked dispatch table. It accepts an expression (delimited by parentheses) and then a sequence of goto labels. You may optionally insert commas between the labels.</p>
    <p>Depending on the value of the expression, the switch statement will jump to one of the entries in the list.</p>
    <pre><code>
        u64 v = cast(u64)get_user_input("Please enter an integer:") % 10;
        switch(v) is0, is1, is2, is3, is4, is5, is6, is7, is8, is9, is10;
        :is0
            println("Got 0!");
            goto after
        :is1
            println("Got 1!");
            goto after
        :is2
            println("Got 2!");
            goto after
        :is3
            println("Got 3!");
            goto after
        :is4
            println("Got 4!");
            goto after
        :is5
            println("Got 5!");
            goto after
        :is6
            println("Got 6!");
            goto after
        :is7
            println("Got 7!");
            goto after
        :is8
            println("Got 8!");
            goto after
        :is9
            println("Got 9!");
        :after
        println("Goodbye!");
        sys_exit(0);
    </code></pre>
    <p>The labels in a switch statement must all be in the same scope as the switch statement- it is not valid for them to be in a parent or child scope. Also note that switch statements in seabass are <i>unchecked</i> meaning that invalid values (negative or >= number of labels in the statement) will result in <b><i>undefined behavior</i></b>.</p>
    <pre><code>
    :lab0
    switch(1) lab0, lab8, lab9; //OK, goto lab8
    switch(7) lab0, lab8, lab9; //UNDEFINED BEHAVIOR
    switch(1) lab0, lab1, lab2; //ERROR!
    for(1,1,1)
        :lab1
        :lab2
        switch(0) lab0, lab8, lab9; //ERROR!
        switch(3) lab1 lab2 lab5 lab6 lab7; //OK, goto lab6
        switch(3) lab1 lab2, lab5; //UNDEFINED BEHAVIOR
        switch(1) lab1, lab2, lab3, lab4; //ERROR!
        if(1)
            :lab3
            :lab4
            switch(1) lab3, lab4; //OK, goto lab4
            switch(1) lab1 lab2; //ERROR!
        end
        :lab5
        :lab6
        switch(1) lab1 lab2 lab5 lab6 lab7; //OK, goto lab2
        :lab7
    end
    :lab8
    :lab9
    switch(2) lab0, lab8, lab9; //OK, goto lab9
    </code></pre>
    <p><i>Please study the example above carefully</i></p>
    <hr>
    <center>
    <h2 id="datastmt">Data Statement</h2>
    </center>
    <hr>
    <p>Inherited from BASIC, the data statement allows you
    to store large amounts of static global data in your program.</p>
    <p>It exists as a replacement for array initializers, which Seabass lacks.</p>
    <pre><code>
    data int myintegers 
    1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
    16,17,18,19,20,21,22,23,24,25,26,27,
    1<<31,1<<32;
    </code></pre>
    <p>This allows you to store arbitrary data into a program.</p>
    <p>Note that data statements may also store strings:</p>
    <pre><code>
    data public string mystring "Hello world!";
    </code></pre>
    <hr>
    <center>
    <h2 id="qualifiers">Symbol Qualifiers</h2>
    </center>
    <hr>
    <p>Seabass supports a wide variety of qualifiers that can be attached to functions, methods, global variables, and data statements. <i>Qualifiers may not be applied to local variables</i>.</p>
    <p>Here is a list of them, along with a brief description of what they do:</p>
    <ul>
        <li><b>codegen</b><br>
            Applies to: functions, methods, global variables, data statements<br>
            <i><b>What does it do?</b></i><br>
            Makes the symbol compiletime-only. The symbol
            is used during 'code generation' (codegen) time-
            while the source code is being parsed and when
            codegen_main is invoked.
        </li>
        <li><b>predecl</b><br>
            Applies to: functions, methods, global variables, data statements<br>
            <i><b>What does it do?</b></i><br>
            Forces the statement to be a predeclaration, rather than a definition. This is
            essentially Seabass's version of C's 'extern'. It is never valid to include
            a function or method definition in a predeclaration.
        </li>
        <li><b>noexport</b><br>
            Applies to: functions, methods, global variables, data statements, <i>classes, structs</i><br>
            <i><b>What does it do?</b></i><br>
            Marks the symbol to not be exported- the rest of the unit will
            compile to the target as if the symbol was defined, but it will
            neither be defined or predeclared. This is useful if you want
            to allow seabass to seamlessly call functions already written
            in the target language.
        </li>
        <li><b>public</b><br>
            Applies to: functions, methods, global variables, data statements<br>
            <i><b>What does it do?</b></i><br>
            Marks the symbol to be visible in other compilation units.
        </li>
        <li><b>static</b><br>
            Applies to: functions, methods, global variables, data statements<br>
            <i><b>What does it do?</b></i><br>
            Marks the symbol to be invisible in other compilation units. This is
            the default.
        </li>
        <li><b>atomic</b><br>
            Applies to: global variables<br>
            <i><b>What does it do?</b></i><br>
            All reads and writes to the symbol shall be atomic, i.e., you will
            never have a partial read or write, even with multiple threads accessing
            the same variable.
        </li>
        <li><b>volatile</b><br>
            Applies to: global variables<br>
            <i><b>What does it do?</b></i><br>
            No compiler optimizations may be done on the variable (or for pointers:
            the variable pointed to).
        </li>
        <li><b>inline</b><br>
            Applies to: functions, methods<br>
            <i><b>What does it do?</b></i><br>
            Indicates to the compiler that the function/method should be inlined,
            rather than be separate code.
        </li>
        <li><b>pure</b><br>
            Applies to: functions, methods<br>
            <i><b>What does it do?</b></i><br>
            Indicates that the function/method does not alter any global state
            accessible by the program, and always performs the same operation
            every single time. I.e., a "Pure function".
        </li>
        <li><b>union</b><br>
            Applies to: <i>structs, classes</i><br>
            <i><b>What does it do?</b></i><br>
            indicates that all members of the struct/class should share the same memory.
        </li>
    </ul>
    <p>Please note that struct/class qualifiers are inserted inside the body of the struct,
    rather than before the word struct.</p>
    <pre><code>
    class myclass
        noexport //this struct should not be exported.
        union //this struct is a union- all members should share the same memory.
        float[4] fmem
        int[4] imem
    end
    </code></pre>
    <hr>
    <center>
    <h2 id="alignment">Alignment</h2>
    </center>
    <hr>
    <p>Seabass allows you to specify the alignment requirement of
    a struct/class by entering an integer somewhere in the body
    of the struct.</p>
    <pre><code>
    class vec4
        16 //16 byte alignment
        float[4] d
    end
    class mat4
        union
        float[16] d
        vec4[4] columns
        32 //32 byte alignment
    end
    </code></pre>
    <p>Please note that the codegen environment <i><b>ignores</b></i> all alignment
    specifiers of structs/classes. Classes and structs used in the codegen environment
    are considered to have alignment 1.</p>
    <hr>
    <center>
    <h2 id="memberptr">The Member Pointer Operator</h2>
    </center>
    <hr>
    <p>It is possible to obtain the address of any struct/class member
    in Seabass using the <code>.&</code> operator:</p>
    <pre><code>
    class vec4
        float[4] d
        16
    end
    class mat4
        union
        float[16] d
        vec4[4] columns
        32
    end
    
    //later...
    mat4 mymat4;
    f32* p;
    float* q;
    p = mymat4.&d;
    q = mymat4.columns[0].&d;
    if(p == q)
        println("Identical!");
    else
        println("Not Identical!");
    end
    </code></pre>
    <hr>
    <center>
    <h2 id="getptr">getglobalptr and getfnptr</h2>
    </center>
    <hr>
    <p>In seabass, you can retrieve a pointer to any global variable
    or function (but not method) using the <code>getglobalptr</code> and <code>getfnptr</code>
    keywords.</p>
    <p>getglobalptr will return the pointer you requested of the correct type (note that
    for arrays and data statements, it will yield the same value as simply writing their
    names).</p>
    <p>getfnptr returns a `byte*` which can be used with callfnptr.</p>
    <hr>
    <center>
    <h2 id="callfnptr">callfnptr</h2>
    </center>
    <hr>
    <p>Using the byte* retrieved from `getfnptr` it is possible to invoke a function by pointer:</p>
    <p>This code is lifted from a previous example:</p>
    <pre><code>
    //function whose pointer we take...
    fn myfunction(int a, char* text)->float;
    
    //this function's prototype is used....
    fn noexport template_function(int q, char* t)->float;
    
    //retrieve a pointer to `myfunction`
    byte* mypointer = getfnptr(myfunction);
    
    //call the function...
    float x = callfnptr[template_function](mypointer)(3, "Hello World!");
    </code></pre>
    <hr>
    <center>
    <h2 id="streq">streq and strneq</h2>
    </center>
    <hr>
    <p>Seabass provides two dedicated operators for comparing C-strings- streq and strneq.</p>
    <p>if they are used in target code, the translation unit must provide a compatible</p>
    <p>declaration of <code>impl_streq</code> which, for 64 bit targets, has this prototype:</p>
    <pre><code>
    fn inline pure impl_streq(u8* a, u8* b)->i64;
    </code></pre>
    <p>on 32 bit platforms, it would return i32 (int), and for 16 bit it would return i16 (short).</p>
    <p>This is the implementation used in the `toc` usermode standard library:</p>
    <pre><code>
    fn inline pure impl_streq(char* a, char* b)->TGT_IMAX:
        return strcmp(a,b) == 0
    end
    </code></pre>
    <p>it must be a pure function accepting two byte*'s and returning a signed integer of the target word size.</p>
    <hr>
    <center>
    <h2 id="finale">Fin</h2>
    </center>
    <hr>
    <center>
    <h3>Thank you, beloved.</h3>
    </center>
    <p>This document did not, by any means, cover the entirety of the Seabass programming language,
    or all capabilities of the `cbas` tool. However, the knowledge here should be sufficient
    for you to begin writing programs in Seabass.</p>
    <hr>
    <center>
    <h2 id="blessing">Blessing</h2>
    </center>
    <hr>
    <p>To you, beloved, I wish with all gravity the following for you, in order of importance:</p>
    <p>* That you would know there is one God who made Heaven and Earth in six days. The universe is not billions of years old and you are not related to fish.</p>
    <p>* That you would know that God loves you, and that he gave his only begotten Son, Jesus Christ, so that your sins could be forgiven and you could rise from the dead to live forever with him in eternal everlasting joy and peace, in a place where there is no pain, no crying, and no tears.</p>
    <p>* That during your days here in the age of sin, you would have peace and happiness.</p>
    <p>* That your adventures, both here and hereafter, be grander than you can possibly imagine. May your dreams be not only fulfilled, but superseded in every possible fashion. May your whole life be an epic, a grand story to fill the endless ages to come.</p>
    <p>* That the meager works of my hands would bring you joy in the labor and toil of your hands.</p>
    
    <hr>
    <center>
    <h2 id="license">License</h2>
    </center>
    <hr>
    <pre>
CC0 1.0 Universal

Statement of Purpose

The laws of most jurisdictions throughout the world automatically confer
exclusive Copyright and Related Rights (defined below) upon the creator and
subsequent owner(s) (each and all, an "owner") of an original work of
authorship and/or a database (each, a "Work").

Certain owners wish to permanently relinquish those rights to a Work for the
purpose of contributing to a commons of creative, cultural and scientific
works ("Commons") that the public can reliably and without fear of later
claims of infringement build upon, modify, incorporate in other works, reuse
and redistribute as freely as possible in any form whatsoever and for any
purposes, including without limitation commercial purposes. These owners may
contribute to the Commons to promote the ideal of a free culture and the
further production of creative, cultural and scientific works, or to gain
reputation or greater distribution for their Work in part through the use and
efforts of others.

For these and/or other purposes and motivations, and without any expectation
of additional consideration or compensation, the person associating CC0 with a
Work (the "Affirmer"), to the extent that he or she is an owner of Copyright
and Related Rights in the Work, voluntarily elects to apply CC0 to the Work
and publicly distribute the Work under its terms, with knowledge of his or her
Copyright and Related Rights in the Work and the meaning and intended legal
effect of CC0 on those rights.

1. Copyright and Related Rights. A Work made available under CC0 may be
protected by copyright and related or neighboring rights ("Copyright and
Related Rights"). Copyright and Related Rights include, but are not limited
to, the following:

  i. the right to reproduce, adapt, distribute, perform, display, communicate,
  and translate a Work;

  ii. moral rights retained by the original author(s) and/or performer(s);

  iii. publicity and privacy rights pertaining to a person's image or likeness
  depicted in a Work;

  iv. rights protecting against unfair competition in regards to a Work,
  subject to the limitations in paragraph 4(a), below;

  v. rights protecting the extraction, dissemination, use and reuse of data in
  a Work;

  vi. database rights (such as those arising under Directive 96/9/EC of the
  European Parliament and of the Council of 11 March 1996 on the legal
  protection of databases, and under any national implementation thereof,
  including any amended or successor version of such directive); and

  vii. other similar, equivalent or corresponding rights throughout the world
  based on applicable law or treaty, and any national implementations thereof.

2. Waiver. To the greatest extent permitted by, but not in contravention of,
applicable law, Affirmer hereby overtly, fully, permanently, irrevocably and
unconditionally waives, abandons, and surrenders all of Affirmer's Copyright
and Related Rights and associated claims and causes of action, whether now
known or unknown (including existing as well as future claims and causes of
action), in the Work (i) in all territories worldwide, (ii) for the maximum
duration provided by applicable law or treaty (including future time
extensions), (iii) in any current or future medium and for any number of
copies, and (iv) for any purpose whatsoever, including without limitation
commercial, advertising or promotional purposes (the "Waiver"). Affirmer makes
the Waiver for the benefit of each member of the public at large and to the
detriment of Affirmer's heirs and successors, fully intending that such Waiver
shall not be subject to revocation, rescission, cancellation, termination, or
any other legal or equitable action to disrupt the quiet enjoyment of the Work
by the public as contemplated by Affirmer's express Statement of Purpose.

3. Public License Fallback. Should any part of the Waiver for any reason be
judged legally invalid or ineffective under applicable law, then the Waiver
shall be preserved to the maximum extent permitted taking into account
Affirmer's express Statement of Purpose. In addition, to the extent the Waiver
is so judged Affirmer hereby grants to each affected person a royalty-free,
non transferable, non sublicensable, non exclusive, irrevocable and
unconditional license to exercise Affirmer's Copyright and Related Rights in
the Work (i) in all territories worldwide, (ii) for the maximum duration
provided by applicable law or treaty (including future time extensions), (iii)
in any current or future medium and for any number of copies, and (iv) for any
purpose whatsoever, including without limitation commercial, advertising or
promotional purposes (the "License"). The License shall be deemed effective as
of the date CC0 was applied by Affirmer to the Work. Should any part of the
License for any reason be judged legally invalid or ineffective under
applicable law, such partial invalidity or ineffectiveness shall not
invalidate the remainder of the License, and in such case Affirmer hereby
affirms that he or she will not (i) exercise any of his or her remaining
Copyright and Related Rights in the Work or (ii) assert any associated claims
and causes of action with respect to the Work, in either case contrary to
Affirmer's express Statement of Purpose.

4. Limitations and Disclaimers.

  a. No trademark or patent rights held by Affirmer are waived, abandoned,
  surrendered, licensed or otherwise affected by this document.

  b. Affirmer offers the Work as-is and makes no representations or warranties
  of any kind concerning the Work, express, implied, statutory or otherwise,
  including without limitation warranties of title, merchantability, fitness
  for a particular purpose, non infringement, or the absence of latent or
  other defects, accuracy, or the present or absence of errors, whether or not
  discoverable, all to the greatest extent permissible under applicable law.

  c. Affirmer disclaims responsibility for clearing rights of other persons
  that may apply to the Work or any use thereof, including without limitation
  any person's Copyright and Related Rights in the Work. Further, Affirmer
  disclaims responsibility for obtaining any necessary consents, permissions
  or other rights required for any use of the Work.

  d. Affirmer understands and acknowledges that Creative Commons is not a
  party to this document and has no duty or obligation with respect to this
  CC0 or use of the Work.

For more information, please see
http://creativecommons.org/publicdomain/zero/1.0/

    </pre>
    <p></p>
  </body>
</html>


