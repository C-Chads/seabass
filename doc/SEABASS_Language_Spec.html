<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>153</title>
    <script></script>
  </head>
  <body>
    <!-- Content -->
    <center>
    <h1>
        Seabass Language Reference
    </h1>
    <hr>
    <img src="../logo.png" alt="logo" style="width:100%">
    </center>
    <hr>
    <!-- Index-->
    <div style="margin-left:10%;">
        <a href="../index.html">Main page</a><br>
    </div>
    <hr>
    <div style="margin-left:10%;">
        <a href="#compilationoverview">Compilation Overview</a><br>
        <a href="#format">File Formats and Extensions</a><br>
        <a href="#tokenization">Tokenization</a><br>
        <a href="#preprocessing">Pre-processing</a><br>
        <a href="#parsing">Parsing</a><br>
        <a href="#validation">Validation</a><br>
        <a href="#grammar">Grammar</a><br>
        <a href="#codegen">Codegen Execution Environment</a><br>
        <a href="#license">License</a><br>
    </div>
    <hr>
    <p>
        Welcome, beloved.
        <br><i>Saying, Blessed are they whose iniquities are forgiven, and whose sins are covered.</i> - Romans 4:7
    </p>
    <p>This is a (somewhat) formal specification of the SEABASS programming language. This document should serve to educate future implementers and maintainers as well as curious souls seeking understanding.</p>
    <hr>
    <center>
    <h3>All Glory to the Lord Jesus Christ, who is, and who was, and who is to come, for ever. Amen.</h3>
    </center>
        <hr>
    <center>
    <h2 id="compilationoverview">Compilation Overview</h2>
    </center>
    <hr>
    <p>A valid seabass program shall be comprised of a set of byte-files on a storage medium ("the disk"). A "main file" is passed by-name to the compiler. This file is tokenized and #includes are handled recursively pasting-in token sequences in place of #include.</p>
    <p>After tokenization of all these files is completed, all tokens are "preprocessed" which includes performing #define replacements, transforming string literals, and turning character literals into decimal integer literals.</p>
    <p>Once preprocessing is finished, the translation unit is passed to the main parser. the main parser consumes tokens, producing an AST that represents the structure of the translation unit. This AST must be of a standard-conforming structure and a "reflection library" must be provided. As parsing occurs, the translation unit may invoke a "codegen function" (A special type of previously parsed function in the unit). Codegen functions are given access to the internal structure of the parsed unit (with the exclusion of already-parsed codegen functions, which may be in an implementation-defined format optimized for execution) as well as a variety of "builtin" functions to manipulate the state of the compiler, access the host filesystem, and interact with text terminal input/output. These codegen functions may call other codegen functions and access already-parsed and defined codegen symbols. Codegen functions may read the contents of files from disk and write to files on the disk.</p>
    <p>When a main-parser-called codegen function returns, control returns to the parser and it continues parsing.</p>
    <p>After parsing is finished, the compiler shall search for a codegen function in the unit called "codegen_main" and call it. If it cannot be found, the compiler may perform some safe implementation-defined behavior, such as printing out the parsed AST or emitting an error.</p>
    <p>The following discrete parts of compilation are defined:</p>
    <ol>
        <li>File Scanning and Tokenization - The source code is tokenized and all #include preprocessing directives are handled.</li>
        <li>Preprocessing - String literals are processed to remove quotation marks and convert escape sequences for the parser. #define macro directives are handled. all whitespace is removed. character literals are converted to decimal integer literals.</li>
        <li>Parsing/Validation - the translation unit is parsed into the AST. functions are validated as they are parsed. parsehooks are called where appropriate.</li>
        <li>codegen_main invocation - the compiler searches for the codegen function `codegen_main` and attempts to call it. if it does not exist, it performs some implementation-defined graceful exit behavior (such as emitting an error, printing out the parsed AST, or etcetera).</li>
    </ol>
    <p></p>
    <hr>
    <center>
    <h2 id="format">File Formats and Extensions</h2>
    </center>
    <hr>
    <p>The following file extensions should be used for Seabass source code:</p>
    <p><code>.cbas</code> - a main source code file.</p>
    <p><code>.hbas</code> - a header to be included in the translation unit using #include.</p>
    <p><code>(none)</code> - For system library headers.</p>
    <p>Seabass source code files are to be ASCII only. No null bytes, or bytes greater than 127 (0x00, 0x7F) may appear.</p>
    <p>Individual lines of source code are to be terminated with `\n` (Ascii 0xA).</p>
    <hr>
    <center>
    <h2 id="tokenization">Tokenization</h2>
    </center>
    <hr>
    <p>Seabass programs are tokenized into a linked list of tokens. The list of tokens is as follows:</p>
    <ol>
        <li>whitespace (all non-newline space characters)</li>
        <li>newlines. Character sequences include \r\n, \n\r, and \n.</li>
        <li>string literals. C-style, but may be multi-line.</li>
        <li>character literals. C-style,</li>
        <li>comments. Either C style (<code>/*text*/</code>) or C++ style (<code>//text\n</code>)</li>
        <li>integer constants. These may be octal (starting with 0) or decimal (not starting with 0) or hex (prefixed by 0x or 0X, followed by a sequence of zero or more hexidecimal digits, 0123456789ABCDEFabcdef where 0xA == 0xa == 0x9+0x1)</li>
        <li>Floating point constants. C-style. These are valid:        
        <pre><code>
        1e3
        1e-3
        1.0e-3
        0.e-3
        0.0e-3
        1024.04567e29
        09937.04567e-28
        934.e21
        </code></pre>
        Note that all floating point constants are decimal.
        </li>
        <li>identifiers. Begin with an underscore or alphabetical character, followed by underscores, alphabetic characters, or numbers. C-style identifier rules.<br>
        These are all valid identifiers:
        <pre><code>
        _
        a
        b
        i
        __
        _a
        _b23
        a___29
        myphonenumber
        not_a_number
        five_is_5_and_nine_is_9
        </code></pre>
        But these are not:
        <pre><code>
        1_          //integer literal '1' followed by identifier '_'
        37waystodie //integer literal 37 followed by identifier 'waystodie'
        2           //decimal constant
        0xhello!    //hex literal '0x', identifier 'hello', operator '!'
        </code></pre>        
        </li>
        <li>operators. One of these sequences (equivalent operators are listed on the same line, comma separated):
    
    <pre><code>
    ++
    --
    :=
    :
    <=
    <
    >=
    >
    != , neq
    == , === , eq
    ->
    .&
    &
    &&
    |
    ||
    >>
    <<
    ~
    !
    .
    &
    *
    +
    -
    /
    %
    ^
    |
    ?
    =
    @
    streq
    strneq
    </code></pre>
    Note that it is NOT valid to simply replace operators with equivalent ones.<br>
    Also note that comma IS NOT an operator.
    </li>
        <li>the opening curly brace <code>{</code></li>
        <li>the closing curly brace <code>}</code></li>
        <li>the opening parenthesis <code>(</code></li>
        <li>the closing parenthesis <code>)</code></li>
        <li>the opening square bracket <code>[</code></li>
        <li>the closing square bracket <code>]</code></li>
        <li>semicolon <code>;</code></li>
        <li>"unknown" symbols (anything not mentioned in this document)</li>
        <li>keywords, which are always valid identifiers. "Equivalent" keywords are
        separated by hyphens:
    <pre><code>
    fn - function - func - procedure - proc
    cast
    u8 - char - uchar - byte - ubyte
    i8 - schar - sbyte
    u16 - ushort
    i16 - short - sshort
    u32 - uint - ulong
    i32 - int - sint - long - slong
    u64 - ullong - qword - uqword - uptr
    i64 - llong - sllong - sqword
    f32 - float
    f64 - double
    noexport
    break
    data
    string
    end
    continue
    if
    elif - elseif
    else
    while
    for
    goto - jump
    switch
    return
    tail
    sizeof
    static
    pub - public
    predecl
    struct - class
    union
    method
    codegen
    constexpri
    constexprf
    pure
    inline
    atomic
    volatile
    getfnptr
    callfnptr
    getglobalptr
    asm
    </code></pre>
    Note that it is NOT valid to simply replace all instances of a keyword with
    an "equivalent" keyword.
        
        </li>
        <li>Escaped newlines. <code>\</code> followed by a newline sequence.</li>
        <li>Comma. <code>,</code></li>
        <li>the hashtag symbol/pound sign, <code>#</code></li>
        <li>The 'incsys'- a sequence of characters after '#include' beginning with a left angle bracket and terminated by a right angle bracket, as in <code>#include &ltfile.hbas&gt</code></li>
        <li><code>#include</code> (single token)</li>
        <li><code>#define</code> (single token)</li>
        <li><code>#undef</code> (single token)</li>
        <li><code>#guard</code> (single token)</li>
    </ol>
    <p>Whitespace, newline, escaped newline, #include, #define, #undef, and incsys shall be handled properly and removed from the token sequence during preprocessing. None of these sequences shall ever reach the parser, or it is <i>undefined behavior</i>. Character literals shall be converted to decimal integer literals, and shall not reach the parser, or it is <i>undefined behavior</i>.</p>
    <p></p>
    <hr>
    <center>
    <h2 id="preprocessing">Pre-processing</h2>
    </center>
    <hr>
    <ol>
        <li>All #define sequences (beginning with #define followed by an identifier and ending with an unescaped newline) shall be used to perform token sequence replacements until a corresponding #undef is found, or until the end of the unit. Note that defines are not expanded</li>
        <li>Character literals are converted to decimal integer constants.</li>
        <li>string literals are processed to remove delimiting quotation marks and convert escape sequences into proper characters.</li>
        <li>Newlines are deleted.</li>
        <li>the tokenized translation unit is passed to the parser</li>
    </ol>
    <p></p>
    <p></p>
    <p></p>
    <hr>
    <center>
    <h2 id="parsing">Parsing</h2>
    </center>
    <hr>
    <p>Seabass begins parsing a sequence of global symbols and directives (zero or more) until the end of the unit, possibly invoking parsehooks. Parsed function definitions are validated immediately after they have finished parsing.</p>
    <p></p>
    <p></p>
    <p></p>
    <hr>
    <center>
    <h2 id="validation">Validation</h2>
    </center>
    <hr>
    <p>Each function body is "validated". It is semantically analyzed. Constructors and destructor calls are inserted. Internal linkages between jump targets are generated. If the implementation supports it, codegen function bodies are converted into a compacted or more efficient representation for execution.</p>
    <p></p>
    <p></p>
    <p></p>
    <hr>
    <center>
    <h2 id="grammar">Grammar</h2>
    </center>
    <hr>
    <p>Due to Seabass's mutable syntax, it is not practical (likely impossible) to write a complete specification of its grammar- because the grammar can be extended. However, in broad perspective, the base-level language's grammar looks roughly like this...</p>
    <pre><code>
    TRANSLATION_UNIT = PARSE_GLOBAL+
    PARSE_GLOBAL = ";" | "__cbas_run_fn" IDENT 
                       | "@" IDENT //may alter tokens after it....
                       | "#" "__CBAS_TARGET_WORDSZ" ("64" | "32" | "16" | "8")
                       | "#" "__CBAS_TARGET_MAX_FLOAT" ("64" | "32")
                       | "#" "__CBAS_TARGET_DISABLE_FLOAT" 
                       | "#" "__CBAS_TERMINATE" 
                       | DATA_STMT
                       | PARSE_STRUCTDECL
                       | PARSE_FN
                       | PARSE_METHOD
                       | PARSE_GVARDECL
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
    REPEATEDLY_TRY_METAPROGRAMMING = ("@" IDENT)* //may alter tokens after it...
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
    
    PARSE_TYPE = (IDENT_TYPENAME|KEYWORD_TYPENAME) "*"* ("[" REPEATEDLY_TRY_METAPROGRAMMING CONSTEXPRI "]")? //question mark means "zero or one"
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
    
    DATA_STMT = "data" (REPEATEDLY_TRY_METAPROGRAMMING | "predecl" | "codegen" | "noexport" | "pub" | "static")*
                    ("string" | PARSE_TYPE) REPEATEDLY_TRY_METAPROGRAMMING IDENT REPEATEDLY_TRY_METAPROGRAMMING
                    ( ((REPEATEDLY_TRY_METAPROGRAMMING (CONSTEXPRI | CONSTEXPRF) ",")+) | STRING_LITERAL) 
                    ";"
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
    
    PARSE_SRUCTDECL = "struct" 
        (REPEATEDLY_TRY_METAPROGRAMMING | PARSE_STRUCTMEMBER | ";" | "noexport" | "union" | INT_LITERAL)* 
        "end" //NOTE: At least one member must be defined...
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    PARSE_STRUCTMEMBER = PARSE_TYPE REPEATEDLY_TRY_METAPROGRAMMING IDENT
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    PARSE_FN = "fn"
                    (REPEATEDLY_TRY_METAPROGRAMMING | "predecl" | "codegen" | "noexport" | "pub" | "static" | "inline" | "pure" )*
                    REPEATEDLY_TRY_METAPROGRAMMING 
                    IDENT
                    (
                        (
                            "("
                                (REPEATEDLY_TRY_METAPROGRAMMING PARSE_TYPE REPEATEDLY_TRY_METAPROGRAMMING  IDENT ",")*
                                (REPEATEDLY_TRY_METAPROGRAMMING PARSE_TYPE REPEATEDLY_TRY_METAPROGRAMMING  IDENT)
                            ")"
                        )
                        |
                        ("(" REPEATEDLY_TRY_METAPROGRAMMING  ")")
                    )
                    (
                        ( //if predeclaration
                            ";"
                        )
                        |
                        ( //definition
                            ":"
                            PARSE_FBODY
                        )
                    )    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    PARSE_METHOD = "method" 
                    (REPEATEDLY_TRY_METAPROGRAMMING | "predecl" | "codegen" | "noexport" | "pub" | "static" | "inline" | "pure" )*
                    PARSE_TYPE ("." | ":")?
                    REPEATEDLY_TRY_METAPROGRAMMING 
                    IDENT
                    (
                        (
                            "("
                                (REPEATEDLY_TRY_METAPROGRAMMING PARSE_TYPE REPEATEDLY_TRY_METAPROGRAMMING  IDENT ",")*
                                (REPEATEDLY_TRY_METAPROGRAMMING PARSE_TYPE REPEATEDLY_TRY_METAPROGRAMMING  IDENT)
                            ")"
                        )
                        |
                        ("(" REPEATEDLY_TRY_METAPROGRAMMING  ")")
                    )
                    (
                        "->"
                        REPEATEDLY_TRY_METAPROGRAMMING
                        PARSE_TYPE
                    )?
                    (
                        ( //if predeclaration
                            ";"
                        )
                        |
                        ( //definition
                            ":"
                            PARSE_FBODY
                        )
                    )
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    PARSE_FBODY = PARSE_STMTS validate_function() //function is validated after body is parsed.
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    PARSE_STMTS = (PARSE_STMT)* "end"
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    PARSE_STMT = (IF | GOTO | LABEL_STMT | FOR | WHILE 
                     | CONTINUE | BREAK | SWITCH | RETURN 
                     | TAIL | ASM | LVARDECL 
                     | ("@" IDENT)
                     | EXPR_STMT
                ) | ";"
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    LABEL_STMT = ":" IDENT
    LVARDECL = PARSE_TYPE REPEATEDLY_TRY_METAPROGRAMMING IDENT ("=" PARSE_EXPR ";"?)?
    GOTO = "goto" REPEATEDLY_TRY_METAPROGRAMMING IDENT
    TAIL = "tail" REPEATEDLY_TRY_METAPROGRAMMING IDENT
    CONTINUE = "continue"
    BREAK = "break"
    RETURN = "return" PARSE_EXPR? ";"?
    EXPR_STMT = PARSE_EXPR ";"?
    WHILE = "while" "(" PARSE_EXPR ")" PARSE_STMTS
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    IF = "if" "(" PARSE_EXPR ")" 
        PARSE_STMTS_ALLOW_ELSE_CHAIN 
    (PARSE_ELSE | PARSE_ELIF)? //based on what PARSE_STMTS_ALLOW_ELSE_CHAIN finds,
                               //we may parse an else or elseif statement...
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    PARSE_ELIF = "elif" "(" PARSE_EXPR ")" 
        PARSE_STMTS_ALLOW_ELSE_CHAIN 
    (PARSE_ELSE | PARSE_ELIF)? //based on what PARSE_STMTS_ALLOW_ELSE_CHAIN finds,
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    PARSE_ELSE = "else" PARSE_STMTS
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    PARSE_STMTS_ALLOW_ELSE_CHAIN = (PARSE_STMT*) ("end" | "else" | "elif") //this looks ahead...
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ASM = "asm" "(" REPEATEDLY_TRY_METAPROGRAMMING STRING_LITERAL ")"
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    SWITCH = "switch" "(" PARSE_EXPR ")" (REPEATEDLY_TRY_METAPROGRAMMING IDENT ","?)+ ";"
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    FOR = "for" "(" PARSE_EXPR ("," | ";") PARSE_EXPR ("," | ";") PARSE_EXPR ")" PARSE_STMTS
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //THE BIG ONE
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    PARSE_EXPR = EXPR_PARSE_MOVE
    EXPR_PARSE_MOVE = EXPR_PARSE_ASSIGN (":=" EXPR_PARSE_MOVE)?
    EXPR_PARSE_ASSIGN = EXPR_PARSE_LOGBOOL ("=" EXPR_PARSE_ASSIGN)?
    EXPR_PARSE_LOGBOOL = EXPR_PARSE_COMPARE (("||" EXPR_PARSE_COMPARE) | ("&&" EXPR_PARSE_COMPARE))*
    EXPR_PARSE_COMPARE = EXPR_PARSE_BIT (
        ("==" EXPR_PARSE_BIT) |
        ("streq" EXPR_PARSE_BIT) |
        ("strneq" EXPR_PARSE_BIT) |
        ("!=" EXPR_PARSE_BIT) |
        (">=" EXPR_PARSE_BIT) |
        (">" EXPR_PARSE_BIT) |
        ("<=" EXPR_PARSE_BIT) |
        ("<" EXPR_PARSE_BIT)
    )*
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    EXPR_PARSE_BIT = EXPR_PARSE_ADDSUB (
        ("|" EXPR_PARSE_ADDSUB) |
        ("&" EXPR_PARSE_ADDSUB) |
        ("^" EXPR_PARSE_ADDSUB) |
        ("<<" EXPR_PARSE_ADDSUB)|
        (">>" EXPR_PARSE_ADDSUB)
    )*
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    EXPR_PARSE_ADDSUB = EXPR_PARSE_MULDIVMOD (
        ("+" EXPR_PARSE_MULDIVMOD)|
        ("-" EXPR_PARSE_MULDIVMOD)
    )*
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    EXPR_PARSE_MULDIVMOD = EXPR_PARSE_PREFIX (
        ("*" EXPR_PARSE_PREFIX)|
        ("/" EXPR_PARSE_PREFIX)|
        ("%" EXPR_PARSE_PREFIX)
    )*
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    EXPR_PARSE_PREFIX = (
        ("!" EXPR_PARSE_PREFIX)|
        ("~" EXPR_PARSE_PREFIX)|
        ("-" EXPR_PARSE_PREFIX)|
        ("--" EXPR_PARSE_PREFIX)|
        ("++" EXPR_PARSE_PREFIX)|
        ("cast" "(" REPEATEDLY_TRY_METAPROGRAMMING PARSE_TYPE ")" EXPR_PARSE_PREFIX)|
        ("(" PARSE_TYPE ")" EXPR_PARSE_PREFIX) //C-style cast... Observe that it does NOT repeatedly try metaprogramming...
    )* EXPR_PARSE_POSTFIX
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    EXPR_PARSE_POSTFIX = EXPR_PARSE_TERMINAL (
        ("[" PARSE_EXPR "]")|
        ("++")|
        ("--")|
        ("." REPEATEDLY_TRY_METAPROGRAMMING 
            (
                //member access..
                IDENT
            )|(
                IDENT "(" 
                    (
                        PARSE_EXPR ","
                    )*
                    PARSE_EXPR?
                ")"
            )
        
        )|
        (".&" REPEATEDLY_TRY_METAPROGRAMMING 
            (
                //member access..
                IDENT
            )
        )|
        (":" REPEATEDLY_TRY_METAPROGRAMMING             
            IDENT "(" 
                (
                    PARSE_EXPR ","
                )*
                PARSE_EXPR?
            ")"
        )
    )*
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    EXPR_PARSE_TERMINAL = (
        (EXPR_PARSE_SIZEOF) |
        (EXPR_PARSE_CONSTEXPRI) |
        (EXPR_PARSE_CONSTEXPRF) |
        (EXPR_PARSE_GETFNPTR) |
        (EXPR_PARSE_CALLFNPTR) |
        (EXPR_PARSE_GETGLOBALPTR) |
        (EXPR_PARSE_FLOATLIT) |
        (EXPR_PARSE_INTLIT) |
        (EXPR_PARSE_BUILTIN_CALL) |
        (EXPR_PARSE_FCALL) |
        (EXPR_PARSE_IDENT) |
        (EXPR_PARSE_PAREN) |
        (EXPR_PARSE_STRING) |
        ("@" IDENT EXPR_PARSE_TERMINAL) //this is actually implemented to "goto top"
    )
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    EXPR_PARSE_SIZEOF = "sizeof" "(" REPEATEDLY_TRY_METAPROGRAMMING PARSE_TYPE ")"
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //AUTHOR'S NOTE: Parsing the number of function arguments here requires knowing what
    //function we're talking about. That's why we have these awkward (ident,)* ? sequences...
    EXPR_PARSE_BUILTIN_CALL = IDENT_BUILTIN_NAME "(" (PARSE_EXPR ",")* PARSE_EXPR? ")"
    EXPR_PARSE_FCALL = IDENT_FNAME "(" (PARSE_EXPR ",")* PARSE_EXPR? ")"
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    EXPR_PARSE_IDENT = IDENT
    EXPR_PARSE_CONSTEXPRI = "constexpri" "(" CONSTEXPRI ")"
    EXPR_PARSE_CONSTEXPRF = "constexprf" "(" CONSTEXPRF ")"
    EXPR_PARSE_GETFNPTR = "getfnptr" "(" REPEATEDLY_TRY_METAPROGRAMMING IDENT ")"
    EXPR_PARSE_GETGLOBALPTR = "getglobalptr" "(" REPEATEDLY_TRY_METAPROGRAMMING IDENT ")"
    EXPR_PARSE_INTLIT = INT_LITERAL
    EXPR_PARSE_FLOATLIT = FLOAT_LITERAL
    EXPR_PARSE_STRING = STRING_LITERAL
    EXPR_PARSE_PAREN = "(" PARSE_EXPR ")"
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    EXPR_PARSE_CALLFNPTR = "callfnptr" 
    "[" REPEATEDLY_TRY_METAPROGRAMMING IDENT_FNAME "]" //the template function
    "(" PARSE_EXPR ")"
    "(" (PARSE_EXPR ",")* PARSE_EXPR? ")" //once again, see note above...
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    CONSTEXPRI = CEXPRI_PARSE_LOGBOOL
    CONSTEXPRF = CEXPRD_PARSE_LOGBOOL
    
    //complete hierarchy for CEXPRD- parsing double math.
    CEXPRD_PARSE_LOGBOOL = CEXPRD_PARSE_COMPARE (
        ("||" CEXPRD_PARSE_COMPARE)|
        ("&&" CEXPRD_PARSE_COMPARE)
    )*
    CEXPRD_PARSE_COMPARE = CEXPRD_PARSE_BIT (
        ("<" CEXPRD_PARSE_BIT)|
        (">" CEXPRD_PARSE_BIT)|
        ("<=" CEXPRD_PARSE_BIT)|
        (">=" CEXPRD_PARSE_BIT)|
        ("==" CEXPRD_PARSE_BIT)|
        ("!=" CEXPRD_PARSE_BIT)
    )*
    CEXPRD_PARSE_BIT = CEXPRD_PARSE_ADDSUB (
        ("|" CEXPRD_PARSE_ADDSUB)|
        ("&" CEXPRD_PARSE_ADDSUB)|
        ("^" CEXPRD_PARSE_ADDSUB)|
        ("<<" CEXPRD_PARSE_ADDSUB)|
        (">>" CEXPRD_PARSE_ADDSUB)
    )*
    CEXPRD_PARSE_ADDSUB = CEXPRD_PARSE_MULDIV (
        ("+" CEXPRD_PARSE_MULDIV)|
        ("-" CEXPRD_PARSE_MULDIV)
    )*
    //doubles dont have modulus..
    CEXPRD_PARSE_MULDIV = CEXPRD_PARSE_PREFIX (
        ("*" CEXPRD_PARSE_PREFIX)|
        ("/" CEXPRD_PARSE_PREFIX)
    )*
    CEXPRD_PARSE_PREFIX = (
        "-"|
        "~"|
        "!"|
        "++"|
        "--"
    )* CEXPRD_PARSE_POSTFIX
    
    CEXPRD_PARSE_POSTFIX = CEXPRD_PARSE_PAREN (
        "++" | "--"
    )*
    CEXPRD_PARSE_PAREN = (
        INT_LITERAL |
        FLOAT_LITERAL |
        IDENT | //a codegen variable.
        ("constexprf" "(" CONSTEXPRF ")") |
        ("constexpri" "(" CONSTEXPRI ")") |
        ("(" CONSTEXPRF ")")
    )
    
    //complete hierarchy for CEXPRI- parsing double math.
    CEXPRI_PARSE_LOGBOOL = CEXPRI_PARSE_COMPARE (
        ("||" CEXPRI_PARSE_COMPARE)|
        ("&&" CEXPRI_PARSE_COMPARE)
    )*
    CEXPRI_PARSE_COMPARE = CEXPRI_PARSE_BIT (
        ("<" CEXPRI_PARSE_BIT)|
        (">" CEXPRI_PARSE_BIT)|
        ("<=" CEXPRI_PARSE_BIT)|
        (">=" CEXPRI_PARSE_BIT)|
        ("==" CEXPRI_PARSE_BIT)|
        ("!=" CEXPRI_PARSE_BIT)
    )*
    CEXPRI_PARSE_BIT = CEXPRI_PARSE_ADDSUB (
        ("|" CEXPRI_PARSE_ADDSUB)|
        ("&" CEXPRI_PARSE_ADDSUB)|
        ("^" CEXPRI_PARSE_ADDSUB)|
        ("<<" CEXPRI_PARSE_ADDSUB)|
        (">>" CEXPRI_PARSE_ADDSUB)
    )*
    CEXPRI_PARSE_ADDSUB = CEXPRI_PARSE_MULDIV (
        ("+" CEXPRI_PARSE_MULDIV)|
        ("-" CEXPRI_PARSE_MULDIV)
    )*
    CEXPRI_PARSE_MULDIV = CEXPRI_PARSE_PREFIX (
        ("*" CEXPRI_PARSE_PREFIX)|
        ("%" CEXPRI_PARSE_PREFIX)|
        ("/" CEXPRI_PARSE_PREFIX)
    )*
    CEXPRI_PARSE_PREFIX = (
        "-"|
        "~"|
        "!"|
        "++"|
        "--"
    )* CEXPRI_PARSE_POSTFIX
    
    CEXPRI_PARSE_POSTFIX = CEXPRI_PARSE_PAREN (
        "++" | "--"
    )*
    CEXPRI_PARSE_PAREN = (
        INT_LITERAL |
        FLOAT_LITERAL |
        IDENT | //a codegen variable.
        ("constexprf" "(" CONSTEXPRF ")") |
        ("constexpri" "(" CONSTEXPRI ")") |
        ("(" CONSTEXPRI ")")
    )
    
    </code></pre>
    <p></p>
    <p></p>
    <p></p>
    <hr>
    <center>
    <h2 id="codegen">Codegen Execution Environment</h2>
    </center>
    <hr>
    <p>Seabass allows the translation unit to write `codegen` code which can be executed during parsetime and from `codegen_main`. </p>
    <p>The general behavior of this execution environment should be trivially discernible from the syntax of the language, however some notable caveats and special notices exist. To save the reader's time, I will gloss over or leave out the "obvious" (for instance, how the if statement works).</p>
    <ol>
        <li>codegen functions may never invoke non-codegen functions, nor directly access non-codegen symbols. They may access non-codegen symbols by retrieving the AST from the compiler.</li>
        <li>__builtin_malloc and __builtin_realloc must return pointers of the maximum useful
        alignment on the host architecture.</li>
        <li>the internal data types of the CBAS tool on the host system must be able to be perfectly reflected in the codegen environment.</li>
        <li>The codegen environment must behave as if it is running on a byte-addressable system. If this is not actually the case, a virtualization layer must be provided.</li>
        <li>It is undefined behavior for a codegen function called from a <code>__cbas_run_fn</code> directive to attempt to access or modify the list of unparsed tokens, for instance, by invoking `__builtin_peek()` or invoking `__builtin_consume()`</li>
        <li>It is undefined how the bodies of codegen functions are stored after the function has finished parsing. An internal representation (such as native machine code, a bytecode, or a compacted version of the AST) may be used.</li>
        <li>array and struct local variables must be stored in aligned memory, aligned to the maximum useful alignment.</li>
        <li>When converting a small signed integer to a larger unsigned value the integer is first sign-extended as if to convert to the larger signed equivalent. For instance, if an 8 bit signed integer is promoted to an unsigned 32 bit integer, it will first be sign-extended to a signed 32 bit integer, and then demoted to an unsigned 32 bit integer.<br>
        <pre><code>
    i8 v1 = -1
    u32 d1 = v1 //should be promoted from 0xff to 0xffFFffFF
    i32 d2 = v1 //same
    if(d1 != d2)
        __builtin_puts("<ERROR> Sign extension is improperly implemented!");
        __builtin_exit(1);
    end
        </code></pre>
        </li>
        <li></li>
        <li></li>
    </ol>
    <h3>Valid optimizations of codegen functions</h3>
    <ol>
        <li>replacement of the body of the function with a compacted, bytecode, or native machine code representation, or some non-null handle.</li>
        <li>Any optimization which does not change the "net effect" of the code within the constraints of defined behavior.</li>
    </ol>    
    <h3>Invalid optimizations of codegen functions</h3>
    <ol>
        <li>Inlining of other codegen function calls (It must be possible to replace the body of a codegen function which has already been written).</li>
        <li>any change to the code which causes otherwise well-defined behavior to become undefined (such as: assuming signed integer overflow never happens).</li>
        <li>Removal or re-ordering of invocations of builtin functions except __builtin_malloc, __builtin_realloc, and __builtin_free. All other builtin function calls are to be treated as volatile.</li>
        <li>replacement of struct type usage with another struct type defined in the translation unit.</li>
    </ol>
    <h3>Well-Defined behavior</h3>
    <ol>
        <li>The relative order of execution of statements within the body of a codegen function.</li>
        <li>the functionality of each of the __builtin functions (given appropriate input, if the state of the compiler has not been corrupted)</li>
        <li>The functionality of every genera of statement and operator, including the internal dummy statement "STMT_NOP", with the exception of the `asm` statement, which is implementation defined in codegen code.</li>
        <li>The requirement of `tail` that it is a true tail call and is not just a call immediately followed by a return.</li>
        <li>that __builtin_peek(), called from a parsehook (directly or indirectly), will never return a null or invalid pointer.</li>
    </ol>
    <h3>Implementation Defined behavior</h3>
    <ol>
            <li>The relative order of execution of subexpressions in an expression.</li>
            <li>The source of input for `__builtin_gets`.</li>
            <li>The exact semantics of how the host filesystem is accessed with __builtin_open_ofile, __builtin_read_file, etc.</li>
            <li>The functionality of the `asm` statement in codegen functions.</li>
            <li></li>
    </ol>
    <h3>Undefined behavior</h3>
    <ol>
            <li>Dereferencing null, doing naughty things with pointer puns, accessing arrays out of bounds, dividing by zero, using improperly aligned pointers... you can guess.</li>
            <li>passing a negative value, or a value larger than the number of labels into a switch statement.</li>
            <li>Placing the compiler into an invalid state. This will be discussed more later.</li>
            <li>If the compiler has been placed into an invalid state, any operation whatsoever.</li>
            <li>Defining a new global symbol (type, variable, data statement, or function) with the same name as a local variable before that function finishes parsing.</li>
            <li>Altering the contents of parsed and validated codegen functions.</li>
            <li>Deleting a previously defined symbol, or changing its prototype or name.</li>
            <li>Validating the same function twice.</li>
            <li>Validating a function which is not in the compiler's internal symbol table.</li>
            <li>referencing a method by its "real" unmangled function name in code.</li>
            <li></li>
            <li></li>
            <li></li>
    </ol>
    <h3>Invalid Compiler States</h3>
    <p>The main parser for seabass, as well as the codegen code executor, may be written with the following assumptions:</p>
    <ol>
            <li>The system's memory allocators will never fail, i.e. malloc/realloc never return null.</li>
            <li>Codegen code does not define any global symbols that interfere with local symbols while a function is being parsed.</li>
            <li>The placement of a symbol within the symbol table never changes. I.e., once a function/global variable has been given an index into the symbol table, it is permanent and irrevocable.</li>
            <li>The purity of a function will not be altered.</li>
            <li></li>
            <li></li>
            <li></li>
    </ol>
    <p></p>
    <p></p>
    <p></p>
    
    <hr>
    <center>
    <h2 id="license">License</h2>
    </center>
    <hr>
    <pre>
    Statement of Purpose
    
    The laws of most jurisdictions throughout the world automatically confer 
    exclusive Copyright and Related Rights (defined below) upon the creator 
    and subsequent owner(s) (each and all, an "owner") of an original work 
    of authorship and/or a database (each, a "Work").
    
    Certain owners wish to permanently relinquish those rights to a Work for the
    purpose of contributing to a commons of creative, cultural and scientific works
    ("Commons") that the public can reliably and without fear of later claims of
    infringement build upon, modify, incorporate in other works, reuse and redistribute
    as freely as possible in any form whatsoever and for any purposes, including
    without limitation commercial purposes. These owners may contribute to the
    Commons to promote the ideal of a free culture and the further production of
    creative, cultural and scientific works, or to gain reputation or greater
    distribution for their Work in part through the use and efforts of others.
    
    For these and/or other purposes and motivations, and without any expectation of
    additional consideration or compensation, the person associating CC0 with a
    Work (the "Affirmer"), to the extent that he or she is an owner of Copyright
    and Related Rights in the Work, voluntarily elects to apply CC0 to the Work and
    publicly distribute the Work under its terms, with knowledge of his or her
    Copyright and Related Rights in the Work and the meaning and intended legal effect of CC0 on those rights.
    
    1. Copyright and Related Rights. A Work made available under CC0 may be
    protected by copyright and related or neighboring rights
    ("Copyright and Related Rights"). Copyright and Related Rights include, but
    are not limited to, the following:
    
    the right to reproduce, adapt, distribute, perform, display, communicate, and translate a Work;
    moral rights retained by the original author(s) and/or performer(s);
    publicity and privacy rights pertaining to a person's image or likeness depicted in a Work;
    rights protecting against unfair competition in regards to a Work, subject to the limitations in paragraph 4(a), below;
    rights protecting the extraction, dissemination, use and reuse of data in a Work;
    database rights (such as those arising under Directive 96/9/EC of the European Parliament and of the
    Council of 11 March 1996 on the legal protection of databases, and under any national implementation
    thereof, including any amended or successor version of such directive); and other similar, 
    equivalent or corresponding rights throughout the world based on applicable law or treaty,
    and any national implementations thereof.
    2. Waiver. To the greatest extent permitted by, but not in contravention of, applicable law,
    Affirmer hereby overtly, fully, permanently, irrevocably and unconditionally waives, abandons, and
    surrenders all of Affirmer's Copyright and Related Rights and associated claims and causes of action,
    whether now known or unknown (including existing as well as future claims and causes of action),
    in the Work (i) in all territories worldwide, (ii) for the maximum duration provided by applicable
    law or treaty (including future time extensions), (iii) in any current or future medium and for any
    number of copies, and (iv) for any purpose whatsoever, including without limitation commercial,
    advertising or promotional purposes (the "Waiver"). Affirmer makes the Waiver for the benefit of each
    member of the public at large and to the detriment of Affirmer's heirs and successors, fully intending
    that such Waiver shall not be subject to revocation, rescission, cancellation, termination, or any other
    legal or equitable action to disrupt the quiet enjoyment of the Work by the public as contemplated by
    Affirmer's express Statement of Purpose.
    
    3. Public License Fallback. Should any part of the Waiver for any reason be judged legally invalid or
    ineffective under applicable law, then the Waiver shall be preserved to the maximum extent permitted
    taking into account Affirmer's express Statement of Purpose. In addition, to the extent the Waiver is
    so judged Affirmer hereby grants to each affected person a royalty-free, non transferable, 
    non sublicensable, non exclusive, irrevocable and unconditional license to exercise Affirmer's 
    Copyright and Related Rights in the Work (i) in all territories worldwide, (ii) for the maximum 
    duration provided by applicable law or treaty (including future time extensions), (iii) in any current 
    or future medium and for any number of copies, and (iv) for any purpose whatsoever, including without 
    limitation commercial, advertising or promotional purposes (the "License"). The License shall be deemed 
    effective as of the date CC0 was applied by Affirmer to the Work. Should any part of the License for any 
    reason be judged legally invalid or ineffective under applicable law, such partial invalidity or 
    ineffectiveness shall not invalidate the remainder of the License, and in such case Affirmer hereby 
    affirms that he or she will not (i) exercise any of his or her remaining Copyright and Related Rights 
    in the Work or (ii) assert any associated claims and causes of action with respect to the Work, 
    in either case contrary to Affirmer's express Statement of Purpose.
    
    4. Limitations and Disclaimers.
    
    No trademark or patent rights held by Affirmer are waived, abandoned, surrendered, licensed
    or otherwise affected by this document.
    Affirmer offers the Work as-is and makes no representations or warranties of any kind 
    concerning the Work, express, implied, statutory or otherwise, including without limitation 
    warranties of title, merchantability, fitness for a particular purpose, non infringement,
    or the absence of latent or other defects, accuracy, or the present or absence of errors, 
    whether or not discoverable, all to the greatest extent permissible under applicable law.
    Affirmer disclaims responsibility for clearing rights of other persons that may apply to 
    the Work or any use thereof, including without limitation any person's Copyright and Related 
    Rights in the Work. Further, Affirmer disclaims responsibility for obtaining any necessary consents, 
    permissions or other rights required for any use of the Work.
    Affirmer understands and acknowledges that Creative Commons is not a party to this document and has 
    no duty or obligation with respect to this CC0 or use of the Work.
    
    </pre>
    <p></p>
  </body>
</html>


