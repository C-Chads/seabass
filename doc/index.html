<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>153</title>
    <script></script>
  </head>
  <body>
    <!-- Content -->
    <center>
    <h1>
        SEABASS- An Introduction
    </h1>
    <hr>
    <img src="logo.png" alt="logo" style="width:100%">
    <hr>
    </center>
    <!-- Index-->
    <hr>
    <div style="margin-left:10%;">
        <a href="#dedicatory">Dedicatory</a><br>
        <a href="#blessing">Blessing</a><br>
        <a href="#fallible">Notice of Fallibility</a><br>
        <a href="#prereq">Prerequisites</a><br>
        <a href="#terminology">Terminology</a><br>
        <a href="#whatis">What is Seabass?</a><br>
        <a href="#basicsyntaxc">Basic Syntax versus C</a><br>
        <a href="#codegen">codegen</a><br>
        <a href="#codegenmain">codegen_main</a><br>
        <a href="#parsehooks">parsehooks</a><br>
        <a href="#oop">Object Oriented Programming</a><br>
        <a href="#pointers">Pointer Semantics- Differences from C</a><br>
    </div>
    <hr>
    <p>Welcome, conquerors, to the Seabass Metaprogramming language! This html document should serve as an introduction.<br><i>Saying, Blessed are they whose iniquities are forgiven, and whose sins are covered.</i> - Romans 4:7</p>
    <hr>
    <center>
    <h3>All Glory to the Lord Jesus Christ, who is, and who was, and who is to come, for ever. Amen.</h3>
    </center>
    <hr>
    <center>
    <h2 id="dedicatory">Dedicatory</h2>
    </center>
    <hr>
    <p>"Hear, O LORD, when I cry with my voice: have mercy also upon me, and answer me."</p>
    <p>-Ps 27:7</p>
    <hr>
    <p>Seabass, as an idea, a programming language, a working program, and a concept, are all undeserved gifts I have been given. God put it into my hand to build them. For creating heaven and earth in six days, to freely giving us eternal life, to the simple joy of breathing, let all thanks and praise be directed to God our Father and our Lord Jesus Christ. Amen.</p>
    <hr>
    <center>
    <h2 id="blessing">Blessing</h2>
    </center>
    <hr>
    <p>To you, beloved, I wish with all gravity the following for you, in order of importance:</p>
    <p>* That you would know there is one God who made Heaven and Earth in six days. The universe is not billions of years old and you are not related to fish.</p>
    <p>* That you would know that God loves you, and that he gave his only begotten Son, Jesus Christ, so that your sins could be forgiven and you could rise from the dead to live forever with him in eternal everlasting joy and peace, in a place where there is no pain, no crying, and no tears.</p>
    <p>* That during your days here in the age of sin, you would have peace and happiness.</p>
    <p>* That your adventures, both here and hereafter, be grander than you can possibly imagine. May your dreams be not only fulfilled, but superseded in every possible fashion. May your whole life be an epic, a grand story to fill the endless ages to come.</p>
    <p>* That the meager works of my hands would bring you joy in the labor and toil of your hands.</p>
        <hr>
    <center>
    <h2 id="fallible">Notice of Fallibility</h2>
    </center>
    <hr>
    <p>The Seabass programming language, the original C99 implementation, its original standard library, and all of its documentation were authored by a single person. Expect to find mistakes, errors, and omissions.</p>
    <hr>
    <center>
    <h2 id="prereq">Prerequisites</h2>
    </center>
    <hr>
    <p>This documentation is written with the belief that the reader....</p>
    <ol>
        <li>Has a background in Computer Programming, i.e. not a newcomer</li>
        <li>Is passionate about; interested in Computer Programming</li>
        <li>Is an eager independent learner</li>
        <li>Is familiar with at least one systems-level Programming Language- hopefully C</li>
        <li>Can read snippets of C with short explanations</li>
        <li>Can use a search engine to understand terms they are not familiar with</li>
        <li>Is willing to thoroughly read documentation, with backtracking.</li>
    </ol>
    <p>This documentation uses many pieces of terminology which you are likely to be unfamiliar with...</p>
    <hr>
    <center>
    <h2 id="terminology">Terminology</h2>
    </center>
    <hr>
    <p>Note that Italicized terms are considered "standard", meaning that more information should be easily attainable from independent study on the web.</p>
    <ul>
        <li><b>Seabass</b><br>
            <ol>
            <li>The programming language documented by this html document.</li>
            <li>The project surrounding that language</li>
            </ol>
        </li>
        <li><i><b>POSIX</b></i><br>
            An old standard for how operating systems should be designed.<br>
            [Systems programming lingo]
        </li>
        <li><i><b>64 bit</b></i><br>
            <ol>
                <li>Having a 64 bit address space (i.e. "cbas was written for 64 bit byte-addressable POSIX systems")</li>
                <li>Capable of handling 64 bit integer arithmetic in a single operation.</li>
            </ol>
            [Systems programming lingo]
        </li>
        <li><i><b>Byte-addressable</b></i><br>
            Of a computer platform, the ability to address memory by 8-bit chunks. This is as opposed to non-byte-addressable systems, such as the PDP-12, which has memory addressed by 12-bit chunks.<br>
            [Systems programming lingo]
        </li>
        <li><b>CBAS / cbas</b><br>
            The tool which works with Seabass programs, originally written
            in C99 for 64 bit byte-addressable POSIX machines.
        </li>
        <li><i><b>Compiler</b></i><br>
            A piece of code which turns one computer language into another.<br>
            [Programming language lingo]
        </li>
        <li><i><b>AST</b></i><br>
            Internal representation of a program's source code, or a portion thereof, which represents its grammatic structure.<br>[Programming language lingo]
        </li>
        <li><i><b>Token</b></i><br>
            Small piece of source code text.<br>
            [Programming language lingo]
        </li>
        <li><i><b>Parser</b></i><br>
            A piece of computer code which discerns the structure of a computer program from its source code and constructs an AST.<br>
            [Programming language lingo]
        </li>
        <li><i><b>Identifier</b></i><br>
            Name for an object in a computer program. Seabass uses C rules for identifiers.<br>
            [Programming language lingo]
        </li>
        <li><i><b>Keyword</b></i><br>
            Reserved, special sequence of english characters, underscores, and decimal digits. May not start with a digit.<br>[Programming language lingo]
        </li>
        <li><b>codegen</b><br>
            short for "code generation". Adjective. Keyword in the SEABASS language.<br>
            Applied to a function, method, or variable: that function/method/variable
            "exists" only during the execution of the cbas tool.
        </li>
        <li><b>Target</b><br>
            The computer language which a program desires to be compiled for.<br>
            In Seabass, any code which is not "codegen" is considered "target", meaning
            its purpose is to be translated into some other language.
        </li>
        <li><i><b>Domain-Specific Language</b></i><br>
            A computer language designed for a niche in programming, rather than
            general-purpose use.<br>[Programming language lingo]
        </li>
        <li><i><b>Translation unit</b></i><br>
            All the source code connected to a single .cbas file, i.e.
            the main file and everything you `#include` in.<br>[Programming language lingo]
        </li>
        <li><i><b>Recursive descent</b></i><br>
            A scheme for writing parsers.<br>[Programming language lingo]
        </li>
        <li><i><b>Lvalue</b></i><br>
            Assignable and readable value in an expression. When a variable's name is used in an expression, it is an <i>lvalue</i> there.<br>[Programming language lingo]
        </li>

    </ul>
    <hr>
    <center>
    <h2 id="whatis">What is Seabass?</h2>
    </center>
    <hr>
    <p>Seabass is a public domain, self-retargeting, self-extending, self-modifying metaprogramming language, and general purpose metaprogramming tool.</p>
    <p>Allow me to elaborate:</p>
    <ul>
        <li>
            <h3>Public Domain</h3>
            <p>Seabass (language, tool, documentation, libraries, and artwork) are all released to you under the CC0 license. No attribution is required and no license files are needed. These are my gifts to you in perpetuity, so long as you can retain them. May your joy be full.</p>
        </li>
        <li>
            <h3>Language</h3>
            <p>Seabass is a programming language- a written language for expressing computer programs.</p>
        </li>        
        <li>
            <h3>Tool</h3>
            <p>Seabass is an executable computer program (cbas) which can be compiled for 64 bit POSIX-compatible systems with byte-addressable memory. It is used for working with programs written in the Seabass language. To distinguish between the Language and the Tool, the language shall be called "Seabass" and the tool shall be called "cbas" or "CBAS" (all pronounced "SEE BASS"). Tools other than this tool shall not be called "cbas" or "CBAS" but instead shall be referred to by some other name (i.e. "the Seabass Standard Metaprogramming Library").</p>
        </li>
        <li>
            <h3>Metaprogramming</h3>
            <p>Seabass contains special language constructs for writing code which writes code, or manipulates pre-existing code. This is designed to allow the user to implement their own abstractions to the language, even entire new compiled languages.</p>
        </li>
        <li>
            <h3>Self-retargeting</h3>
            <p>Seabass allows the user to define a special function called "codegen_main" which is responsible for generating "target code". This allows programmers to define how their code should be compiled.</p>
        </li>
        <li>
            <h3>Self-extending</h3>
            <p>Seabass allows you to write code which effectively extends the capabilities of the compiler. This can be done within the translation unit and does not require modifying the cbas tool. This code is referred to as "codegen".</p>
        </li>

        <li>
            <h3>Self-modifying</h3>
            <p>codegen code is given virtually unrestricted access to the internals of the compiler. It can modify the tokenized source code which has yet to be parsed, or even manipulate the AST of code which has already been parsed.</p>
        </li>
    </ul>
    <hr>
    <center>
    <h2 id="basicsyntaxc">Basic Syntax versus C</h2>
    </center>
    <hr>
    <p>Seabass's base-level language was designed to be a simplification, enhancement, and general improvement of C. In order to convey the basics of the syntax of Seabass, here is a simple fibonacci number program in both languages:</p>
    <pre><code>
    /*C program*/
    #include &ltstdio.h&gt
    #include &ltstdlib.h&gt
    
    void mutoa(char* dest, unsigned int value);
    unsigned matou(char* in);
    
    static inline unsigned int fib(unsigned n){
        if(n < 2)
            return 1;
        unsigned int a = 1;
        unsigned int b = 1;
        unsigned int c = 1;
        n = n - 2;
        while(n){
            c = a + b;
            a = b;
            b = c;
            n--;
        }
        return c;
    }
    
    int main(int argc, char** argv){
        if(argc < 2){
            puts("Usage: fib 13");
            exit(1);
        }
        puts("Welcome to the fibonacci number calculator!");
        char buf[50];
        unsigned qq = matou(argv[1]);
        puts("You asked for the fibonacci number...");
        mutoa(buf, qq);
        puts(buf);
        puts("That fibonacci number is:");
        mutoa(buf, fib(qq));
        puts(buf);
        return 0;
    }
    
    unsigned matou(char* in){
        unsigned retval = 0;
        while(
            (*in >= '0') &&
            (*in <= '9')
        ){
            retval *= 10;
            retval += *in - '0';
            in++;
        }
        return retval;
    }
    
    void mutoa(char* dest, unsigned value){
        if(value == 0){
            dest[0] = '0';
            dest[1] = 0;
            return;
        }
        {
            unsigned pow;
            pow = 1;
            while(value/pow >= 10){
                pow = pow * 10;
            }
            while(pow){
                unsigned temp;
                temp = value / pow;
                *dest = (temp + ('0')); dest++;
                value = value - temp * pow;
                pow = pow / 10;
            }
        }
        ending:;
        *dest = 0;
    }
    </code></pre>
    <p>Here is an equivalent program in Seabass:</p>
    <pre><code>
    /*Seabass program*/
    #include &lttoc_native_user&gt
    
    @wksht prnt [
        [
            @pprint [println mutoa ARG1]
        ][
            ARG1
        ]
    ]
    
    fn predecl mutoa(char* dest, uint value);
    fn predecl matou(char* in)->uint;
    
    fn inline fib(uint n)->uint:
        if(n < 2)
            return 1;
        end
        uint a=1
        uint b=1
        uint c=1;
        n = n-2
        while(n)
            c = a + b;
            a = b;
            b = c;
            n--
        end
        return c
    end
    
    fn pub main(int argc, schar** argv)->int:
        if(argc < 2)
            @prnt[
                /       "Usage: fib 13"
            ]
            sys_exit(1);
        end
        println("Welcome to the fibonacci number calculator!");
        uint qq = matou((char*)argv[1]);
        @prnt[
            /       "You asked for the fibonacci number..."
            /int    (qq)
            /       "That fibonacci number is:"
            /int    (fib(qq))
        ]
        return 0;
    end
    
    fn codegen codegen_main():
        cg_emitC(SEABASS_STDLIB_PREFIX);
    end
    
    fn matou(char* in)->uint:
        uint retval = 0;
        while(
            (in[0] >= '0') && 
            (in[0] <= '9')
        )
            retval = retval * 10;
            retval = retval + (in[0]-'0');
            in++
        end
        return retval;
    end
    
    fn mutoa(char* dest, uint value):
        if(value == 0)
            dest[0] = '0';
            dest[1] = 0;
            return 
        end
        if(1)
            uint pow
            pow = 1;
            while(value/pow >= 10)
                pow = pow * 10; 
            end
            while(pow)
                uint temp
                temp = value/pow;
                dest[0] = (temp + ('0')); dest++;
                value = value - temp * pow;
                pow = pow / 10
            end
        end
        :ending
        dest[0] = 0
    end
    </code></pre>

    <p>This alone should give you a rough picture of how Seabass "behaves" relative
    to C. Please examine the two programs carefully. I expect you have discerned the following:</p>
    <ol>
        <li>C delimits scopes with brackets, while seabass is more freeform- a scope opens immediately after constructs such as <code>if</code> and <code>while</code>.</li>
        <li>Statements in Seabass do not always require a terminating semicolon.</li>
        <li>in addition to "main" the Seabass program also defines "codegen_main"</li>
        <li>Pointer dereferencing in C can be done with <code>*</code> but in Seabass it is only done with square brackets.</li>
        <li>Return values in seabass are written after the parentheses-delimited function argument list.</li>
        <li>Types in seabass are written slightly differently.</li>
        <li>The seabass program includes several unusual sequences starting with the '@' sign.</li>
    </ol>
    <p>However, most important of all, you should notice that the seabass code is mostly identical in structure
    and semantics to the C code. Seabass is designed to be easy to pick up for C programmers.</p>
    <h3>The @ sign...</h3>
    <p>In Seabass, this is known as the <b>metaprogramming operator</b>. it is used to invoke code at compile time. In this case, it is used to implement the custom syntaxes `wksht` and `pprint`, and in the code provided, we define a new derived syntax, `prnt`.</p>
    <p>The exact nature and semantics of how this all works will be discussed later. All you need to understand right now is that this is the first and most important part of what makes Seabass different from C- the metaprogramming operator. It is the most significant new feature Seabass has over C. Almost all other new features are eclipsed by it.</p>
    <h3>Are they just macros?</h3>
    <p>The word "macro" is used with reckless abandon by many different programming languages. Compilers themselves could be envisioned as giant macros using the definitions used by some programming languages.</p>
    <p>The short answer is <b>No</b>, however <b>the metaprogramming operator is used to implement macros.</b></p>
    <p>I define a macro as "Any simple text replacement scheme which contains minimal or non-existant semantic or syntax rules".</p>
    <p>The `@prnt` operation is a macro, created by invoking `@wksht`, wrapping the `@pprint` Domain-Specific Language.</p>
    <p>The use of the metaprogramming operator will be explained later. We must discuss some pre-requisite concepts first.</p>
    <hr>
    <center>
    <h2 id="codegen">codegen</h2>
    </center>
    <hr>
    <p>Seabass allows you to define functions and variables which exist exclusively at compiletime, i.e., while the `cbas` tool is running. <b>They do not exist in the final compiled program.</b></p>
    <p>These "symbols" are annotated as such using the `codegen` keyword.</p>
    <p>codegen functions may access special `builtin` functions of the `cbas` tool, giving it access to the internals of the compiler, the filesystem, compiletime memory allocation, and etcetera.</p>
    <p>codegen functions are invoked from any of the following:</p>
    <ol>
        <li>Called from another codegen function</li>
        <li>a "parsehook invocation" (using the metaprogramming operator- @)</li>
        <li>the "#__cbas_run_fn" directive.</li>
        <li>After parsing is finished, `codegen_main` is executed.</li>
    </ol>
    <p>All of this happens during execution of `cbas` on a translation unit.</p>
    
    <hr>
    <center>
    <h2 id="codegenmain">codegen_main</h2>
    </center>
    <hr>
    <p>As mentioned <a href="#whatis">before</a> , Seabass is self-retargeting. It allows you to define a function which is responsible for generating the "output" of the compiler.</p>
    <p>In the fibonacci number program from the <a href="#basicsyntaxc">previous section</a>, it was used to generate C code. This C code would then be compiled with a C compiler to generate an executable binary.</p>
    <p>codegen_main is only special in that the `cbas` tool will attempt to find it inside the translation unit after parsing has finished. If it cannot find it, it will print out the parsed AST and then exit.</p>
    <p>In principle, the codegen_main function can generate arbitrary output. It is fully programmable.</p>
    <p>If you should desire to use Seabass as a scripting language, it is possible to write entire programs purely within the confines of `codegen` code, and use the `cbas` tool like a script interpreter. This functionality was used to develop and debug the original implementation.</p>
    <hr>
    <center>
    <h2 id="parsehooks">parsehooks</h2>
    </center>
    <hr>
    <p><i>We are now ready to discuss what the @ sign does.</i></p>
    <p>In seabass, you can write special codegen functions which can be invoked with the metaprogramming operator. Here is how you declare and use one:</p>
    <pre><code>
    proc codegen parsehook_dostuff():
        __builtin_puts("Hello, World!");
    end
    //invocation...
    @dostuff
    </code></pre>
    <p><i>(Note that 'proc' is just an alias for 'fn')</i></p>
    <p>When the parser sees an @ sign followed by an identifier, it looks for a codegen function with that name prefixed by 'parsehook_'. This function is then immediately called. This function can then use builtin functions such as __builtin_peek() to access the tokenized source code of the program and manipulate it. This functionality was used to implement `@wksht` and `@pprint` from <a href="#basicsyntaxc">before</a>.</p>
    <hr>
    <center>
    <h2 id="oop">Object Oriented Programming</h2>
    </center>
    <hr>
    <p>For convenience, Seabass has several features from Object Oriented programming:</p>
    <ol>
        <li>the `class` keyword as an alias for `struct`.</li>
        <li>methods- functions invoked on a struct/class which are specific to that class/struct.</li>
        <li>Automatic constructors and destructors- Functions which are invoked on a struct when it first appears in a scope, and when it disappears.</li>
    </ol>
    <p>Here is a small example program (using entirely codegen code) which demonstrates object oriented programming in Seabass:</p>
    <pre><code>
    /*
        Small program to demonstrate object oriented programming in Seabass.
    */
    
    class myClass
        noexport
        int a
        char* b
    end
    
    codegen int a = 25;
    
    method codegen myClass.ctor():
        this.a = a++;
        char[500] buf
        __builtin_itoa(buf, this.a);
        this.b = __builtin_strdup(buf);
        __builtin_puts("I have been constructed! My string is...");
        __builtin_puts(this.b);
    end
    
    method codegen myClass.dtor():
        __builtin_puts("Goodbye! My string was...");
        __builtin_puts(this.b);
        __builtin_free(this.b);
        a--
    end
    
    method codegen myClass.print():
        __builtin_puts(this.b)
    end
    
    fn codegen codegen_main():
    
        i64 i
        for(i = 0, i < 10; i++)
            myClass qq
            myClass qq2
            myClass qq3
            myClass qq4
            qq3.print()
            if(i == 3) continue end
            qq2.print()
        end
        
        if(1)
            //demo move...
            myClass qq
            myClass qq2
            __builtin_free(qq.b); //ensure we don't leak memory...
            qq := qq2;
            qq2.b = __builtin_strdup("I seem to have lost my old string...");
            qq.print();
            qq2.print();
        end
        return	
    end
    </code></pre>
    <p>As you can see, `.ctor()` and `.dtor()` are methods on the `myClass` type. The `ctor` method is invoked at instantiation, and the `dtor` method is invoked when the object is destroyed. `continue` properly causes objects within a loop body to be destroyed.</p>
    <p>.ctor() and .dtor() methods are NOT automatically called under these circumstances:</p>
    <ol>
        <li>When an array of objects is declared</li>
        <li>When objects are declared at global scope</li>
        <li>When a pointer to an object is declared</li>
        <li>When an object is inside of another object</li>
    </ol>
    <p>You must be especially careful of 4- Seabass will <b>not</b> automatically write constructors and destructors for you, nor automatically insert invocations of member object constructors/destructors. You must write the constructors and destructors for your objects yourself, constructing and destroying member objects where appropriate.</p>
    <p><i>[Note, of course, that because Seabass is a metaprogramming language, it is possible to write languages within Seabass that do not have these limitations...]</i></p>
    <p>Also note that seabass does not have any of the following from object oriented programming:</p>
    <ol>
        <li>Inheritance</li>
        <li>Virtual methods</li>
        <li>Operator overloading</li>
    </ol>
    <p>It <i>does</i> have move semantics. There is a dedicated "move" operator, <code>:=</code> which copies one pointed-to object into another.</p>
    <hr>
    <center>
    <h2 id="pointers">Pointer Semantics- Differences from C</h2>
    </center>
    <hr>
    <p>The syntax of Seabass differs from C most in its usage of pointers. Note the following:</p>
    <ol>
        <li>It is not possible to get the address of local primitive variables. You may not use the `&` operator to take the address of a variable. Taking the address of global variables is done with `getglobalptr`</li>
        <li>There are no function pointers in the type system- all function pointers are `byte*`. They are obtained with `getfnptr` and used with `callfnptr`.</li>
        <li>Structs may never appear by-value in an expression. Structs are always passed by pointer into and out of functions.</li>
        <li>Indexing an array of pointer-to-struct will yield a pointer-to-struct rather than an lvalue struct.</li>
        <li>Just like C, arrays decay into pointers in an expression.</li>
        <li>Seabass has a dedicated `memcpy` operator, called the `move` operator `<code>:=</code>`.</li>
        <li>Seabass has two dedicated C-string comparison operators, `streq` and `strneq`.</li>
        <li></li>
    </ol>
    <p></p>
    <p></p>
  </body>
</html>
