<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>153</title>
    <script></script>
  </head>
  <body>
    <!-- Content -->
    <center>
    <h1>
        SEABASS- An Introduction
    </h1>
    <hr>
    <img src="logo.png" alt="logo" style="width:100%">
    <hr>
    </center>
    <!-- Index-->
    <hr>
    <div style="margin-left:10%;">
        <a href="#dedicatory">Dedicatory</a><br>
        <a href="#blessing">Blessing</a><br>
        <a href="#fallible">Notice of Fallibility</a><br>
        <a href="#prereq">Prerequisites</a><br>
        <a href="#terminology">Terminology</a><br>
        <a href="#whatis">What is Seabass?</a><br>
        <a href="#basicsyntaxc">Basic Syntax versus C</a><br>
        <a href="#codegen">codegen</a><br>
        <a href="#codegenmain">codegen_main</a><br>
        <a href="#parsehooks">parsehooks</a><br>
        <a href="#syntaxsemantics">Syntax Semantics</a><br>
        <a href="#oop">Object Oriented Programming</a><br>
        <a href="#pointers">Pointer Semantics</a><br>
        <a href="#tailcall">Tail Calls</a><br>
        <a href="#typedecl">Type Declaration Semantics</a><br>
        <a href="#typealiases">Type Alias List</a><br>
        <a href="#keywords">Keyword List</a><br>
        <a href="#gotolabels">Labels</a><br>
        <a href="#switch">Switch Statement</a><br>
    </div>
    <hr>
    <p>Welcome, conquerors, to the Seabass Metaprogramming language! This html document should serve as an introduction.<br><i>Saying, Blessed are they whose iniquities are forgiven, and whose sins are covered.</i> - Romans 4:7</p>
    <hr>
    <center>
    <h3>All Glory to the Lord Jesus Christ, who is, and who was, and who is to come, for ever. Amen.</h3>
    </center>
    <hr>
    <center>
    <h2 id="dedicatory">Dedicatory</h2>
    </center>
    <hr>
    <p>"Hear, O LORD, when I cry with my voice: have mercy also upon me, and answer me."</p>
    <p>-Ps 27:7</p>
    <hr>
    <p>Seabass, as an idea, a programming language, a working program, and a concept, are all undeserved gifts I have been given. God put it into my hand to build them. For creating heaven and earth in six days, to freely giving us eternal life, to the simple joy of breathing, let all thanks and praise be directed to God our Father and our Lord Jesus Christ. Amen.</p>
    <hr>
    <center>
    <h2 id="blessing">Blessing</h2>
    </center>
    <hr>
    <p>To you, beloved, I wish with all gravity the following for you, in order of importance:</p>
    <p>* That you would know there is one God who made Heaven and Earth in six days. The universe is not billions of years old and you are not related to fish.</p>
    <p>* That you would know that God loves you, and that he gave his only begotten Son, Jesus Christ, so that your sins could be forgiven and you could rise from the dead to live forever with him in eternal everlasting joy and peace, in a place where there is no pain, no crying, and no tears.</p>
    <p>* That during your days here in the age of sin, you would have peace and happiness.</p>
    <p>* That your adventures, both here and hereafter, be grander than you can possibly imagine. May your dreams be not only fulfilled, but superseded in every possible fashion. May your whole life be an epic, a grand story to fill the endless ages to come.</p>
    <p>* That the meager works of my hands would bring you joy in the labor and toil of your hands.</p>
        <hr>
    <center>
    <h2 id="fallible">Notice of Fallibility</h2>
    </center>
    <hr>
    <p>The Seabass programming language, the original C99 implementation, its original standard library, and all of its documentation were authored by a single person. Expect to find mistakes, errors, and omissions.</p>
    <hr>
    <center>
    <h2 id="prereq">Prerequisites</h2>
    </center>
    <hr>
    <p>This documentation is written with the belief that the reader....</p>
    <ol>
        <li>Has a background in Computer Programming, i.e. not a newcomer</li>
        <li>Is passionate about; interested in Computer Programming</li>
        <li>Is an eager independent learner</li>
        <li>Is familiar with at least one systems-level Programming Language- hopefully C</li>
        <li>Can read snippets of C with short explanations</li>
        <li>Can use a search engine to understand terms they are not familiar with</li>
        <li>Is willing to thoroughly read documentation, with backtracking.</li>
    </ol>
    <p>This documentation uses many pieces of terminology which you are likely to be unfamiliar with...</p>
    <hr>
    <center>
    <h2 id="terminology">Terminology</h2>
    </center>
    <hr>
    <p>Note that Italicized terms are considered "standard", meaning that more information should be easily attainable from independent study on the web.</p>
    <ul>
        <li><b>Seabass</b><br>
            <ol>
            <li>The programming language documented by this html document.</li>
            <li>The project surrounding that language</li>
            </ol>
        </li>
        <li><i><b>POSIX</b></i><br>
            An old standard for how operating systems should be designed.<br>
            [Systems programming lingo]
        </li>
        <li><i><b>64 bit</b></i><br>
            <ol>
                <li>Having a 64 bit address space (i.e. "cbas was written for 64 bit byte-addressable POSIX systems")</li>
                <li>Capable of handling 64 bit integer arithmetic in a single operation.</li>
            </ol>
            [Systems programming lingo]
        </li>
        <li><i><b>Byte-addressable</b></i><br>
            Of a computer platform, the ability to address memory by 8-bit chunks. This is as opposed to non-byte-addressable systems, such as the PDP-12, which has memory addressed by 12-bit chunks.<br>
            [Systems programming lingo]
        </li>
        <li><b>CBAS / cbas</b><br>
            The tool which works with Seabass programs, originally written
            in C99 for 64 bit byte-addressable POSIX machines.
        </li>
        <li><i><b>Compiler</b></i><br>
            A piece of code which turns one computer language into another.<br>
            [Programming language lingo]
        </li>
        <li><i><b>AST</b></i><br>
            Internal representation of a program's source code, or a portion thereof, which represents its grammatic structure.<br>[Programming language lingo]
        </li>
        <li><i><b>Token</b></i><br>
            Small piece of source code text.<br>
            [Programming language lingo]
        </li>
        <li><i><b>Parser</b></i><br>
            A piece of computer code which discerns the structure of a computer program from its source code and constructs an AST.<br>
            [Programming language lingo]
        </li>
        <li><i><b>Identifier</b></i><br>
            Name for an object in a computer program. Seabass uses C rules for identifiers.<br>
            [Programming language lingo]
        </li>
        <li><i><b>Keyword</b></i><br>
            Reserved, special sequence of english characters, underscores, and decimal digits. May not start with a digit.<br>[Programming language lingo]
        </li>
        <li><b>codegen</b><br>
            short for "code generation". Adjective. Keyword in the SEABASS language.<br>
            Applied to a function, method, or variable: that function/method/variable
            "exists" only during the execution of the cbas tool.
        </li>
        <li><b>Target</b><br>
            The computer language which a program desires to be compiled for.<br>
            In Seabass, any code which is not "codegen" is considered "target", meaning
            its purpose is to be translated into some other language.
        </li>
        <li><i><b>Domain-Specific Language</b></i><br>
            A computer language designed for a niche in programming, rather than
            general-purpose use.<br>[Programming language lingo]
        </li>
        <li><i><b>Translation unit</b></i><br>
            All the source code connected to a single .cbas file, i.e.
            the main file and everything you `#include` in.<br>[Programming language lingo]
        </li>
        <li><i><b>Recursive descent</b></i><br>
            A scheme for writing parsers.<br>[Programming language lingo]
        </li>
        <li><i><b>Lvalue</b></i><br>
            Assignable and readable value in an expression. When a variable's name is used in an expression, it is an <i>lvalue</i> there.<br>[Programming language lingo]
        </li>

    </ul>
    <hr>
    <center>
    <h2 id="whatis">What is Seabass?</h2>
    </center>
    <hr>
    <p>Seabass is a public domain, self-retargeting, self-extending, self-modifying metaprogramming language, and general purpose metaprogramming tool.</p>
    <p>Allow me to elaborate:</p>
    <ul>
        <li>
            <h3>Public Domain</h3>
            <p>Seabass (language, tool, documentation, libraries, and artwork) are all released to you under the CC0 license. No attribution is required and no license files are needed. These are my gifts to you in perpetuity, so long as you can retain them. May your joy be full.</p>
        </li>
        <li>
            <h3>Language</h3>
            <p>Seabass is a programming language- a written language for expressing computer programs.</p>
        </li>        
        <li>
            <h3>Tool</h3>
            <p>Seabass is an executable computer program (cbas) which can be compiled for 64 bit POSIX-compatible systems with byte-addressable memory. It is used for working with programs written in the Seabass language. To distinguish between the Language and the Tool, the language shall be called "Seabass" and the tool shall be called "cbas" or "CBAS" (all pronounced "SEE BASS"). Tools other than this tool shall not be called "cbas" or "CBAS" but instead shall be referred to by some other name (i.e. "the Seabass Standard Metaprogramming Library").</p>
        </li>
        <li>
            <h3>Metaprogramming</h3>
            <p>Seabass contains special language constructs for writing code which writes code, or manipulates pre-existing code. This is designed to allow the user to implement their own abstractions to the language, even entire new compiled languages.</p>
        </li>
        <li>
            <h3>Self-retargeting</h3>
            <p>Seabass allows the user to define a special function called "codegen_main" which is responsible for generating "target code". This allows programmers to define how their code should be compiled.</p>
        </li>
        <li>
            <h3>Self-extending</h3>
            <p>Seabass allows you to write code which effectively extends the capabilities of the compiler. This can be done within the translation unit and does not require modifying the cbas tool. This code is referred to as "codegen".</p>
        </li>

        <li>
            <h3>Self-modifying</h3>
            <p>codegen code is given virtually unrestricted access to the internals of the compiler. It can modify the tokenized source code which has yet to be parsed, or even manipulate the AST of code which has already been parsed.</p>
        </li>
    </ul>
    <hr>
    <center>
    <h2 id="basicsyntaxc">Basic Syntax versus C</h2>
    </center>
    <hr>
    <p>Seabass's base-level language was designed to be a simplification, enhancement, and general improvement of C. In order to convey the basics of the syntax of Seabass, here is a simple fibonacci number program in both languages:</p>
    <pre><code>
    /*C program*/
    #include &ltstdio.h&gt
    #include &ltstdlib.h&gt
    
    void mutoa(char* dest, unsigned int value);
    unsigned matou(char* in);
    
    static inline unsigned int fib(unsigned n){
        if(n < 2)
            return 1;
        unsigned int a = 1;
        unsigned int b = 1;
        unsigned int c = 1;
        n = n - 2;
        while(n){
            c = a + b;
            a = b;
            b = c;
            n--;
        }
        return c;
    }
    
    int main(int argc, char** argv){
        if(argc < 2){
            puts("Usage: fib 13");
            exit(1);
        }
        puts("Welcome to the fibonacci number calculator!");
        char buf[50];
        unsigned qq = matou(argv[1]);
        puts("You asked for the fibonacci number...");
        mutoa(buf, qq);
        puts(buf);
        puts("That fibonacci number is:");
        mutoa(buf, fib(qq));
        puts(buf);
        return 0;
    }
    
    unsigned matou(char* in){
        unsigned retval = 0;
        while(
            (*in >= '0') &&
            (*in <= '9')
        ){
            retval *= 10;
            retval += *in - '0';
            in++;
        }
        return retval;
    }
    
    void mutoa(char* dest, unsigned value){
        if(value == 0){
            dest[0] = '0';
            dest[1] = 0;
            return;
        }
        {
            unsigned pow;
            pow = 1;
            while(value/pow >= 10){
                pow = pow * 10;
            }
            while(pow){
                unsigned temp;
                temp = value / pow;
                *dest = (temp + ('0')); dest++;
                value = value - temp * pow;
                pow = pow / 10;
            }
        }
        ending:;
        *dest = 0;
    }
    </code></pre>
    <p>Here is an equivalent program in Seabass:</p>
    <pre><code>
    /*Seabass program*/
    #include &lttoc_native_user&gt
    
    @wksht prnt [
        [
            @pprint [println mutoa ARG1]
        ][
            ARG1
        ]
    ]
    
    fn predecl mutoa(char* dest, uint value);
    fn predecl matou(char* in)->uint;
    
    fn inline fib(uint n)->uint:
        if(n < 2)
            return 1;
        end
        uint a=1
        uint b=1
        uint c=1;
        n = n-2
        while(n)
            c = a + b;
            a = b;
            b = c;
            n--
        end
        return c
    end
    
    fn pub main(int argc, schar** argv)->int:
        if(argc < 2)
            @prnt[
                /       "Usage: fib 13"
            ]
            sys_exit(1);
        end
        println("Welcome to the fibonacci number calculator!");
        uint qq = matou((char*)argv[1]);
        @prnt[
            /       "You asked for the fibonacci number..."
            /int    (qq)
            /       "That fibonacci number is:"
            /int    (fib(qq))
        ]
        return 0;
    end
    
    fn codegen codegen_main():
        cg_emitC(SEABASS_STDLIB_PREFIX);
    end
    
    fn matou(char* in)->uint:
        uint retval = 0;
        while(
            (in[0] >= '0') && 
            (in[0] <= '9')
        )
            retval = retval * 10;
            retval = retval + (in[0]-'0');
            in++
        end
        return retval;
    end
    
    fn mutoa(char* dest, uint value):
        if(value == 0)
            dest[0] = '0';
            dest[1] = 0;
            return 
        end
        if(1)
            uint pow
            pow = 1;
            while(value/pow >= 10)
                pow = pow * 10; 
            end
            while(pow)
                uint temp
                temp = value/pow;
                dest[0] = (temp + ('0')); dest++;
                value = value - temp * pow;
                pow = pow / 10
            end
        end
        :ending
        dest[0] = 0
    end
    </code></pre>

    <p>This alone should give you a rough picture of how Seabass "behaves" relative
    to C. Please examine the two programs carefully. I expect you have discerned the following:</p>
    <ol>
        <li>C delimits scopes with brackets, while seabass is more freeform- a scope opens immediately after constructs such as <code>if</code> and <code>while</code>.</li>
        <li>Statements in Seabass do not always require a terminating semicolon.</li>
        <li>in addition to "main" the Seabass program also defines "codegen_main"</li>
        <li>Pointer dereferencing in C can be done with <code>*</code> but in Seabass it is only done with square brackets.</li>
        <li>Return values in seabass are written after the parentheses-delimited function argument list.</li>
        <li>Types in seabass are written slightly differently.</li>
        <li>The seabass program includes several unusual sequences starting with the '@' sign.</li>
    </ol>
    <p>However, most important of all, you should notice that the seabass code is mostly identical in structure
    and semantics to the C code. Seabass is designed to be easy to pick up for C programmers.</p>
    <h3>The @ sign...</h3>
    <p>In Seabass, this is known as the <b>metaprogramming operator</b>. it is used to invoke code at compile time. In this case, it is used to implement the custom syntaxes `wksht` and `pprint`, and in the code provided, we define a new derived syntax, `prnt`.</p>
    <p>The exact nature and semantics of how this all works will be discussed later. All you need to understand right now is that this is the first and most important part of what makes Seabass different from C- the metaprogramming operator. It is the most significant new feature Seabass has over C. Almost all other new features are eclipsed by it.</p>
    <h3>Are they just macros?</h3>
    <p>The word "macro" is used with reckless abandon by many different programming languages. Compilers themselves could be envisioned as giant macros using the definitions used by some programming languages.</p>
    <p>The short answer is <b>No</b>, however <b>the metaprogramming operator is used to implement macros.</b></p>
    <p>I define a macro as "Any simple text replacement scheme which contains minimal or non-existant semantic or syntax rules".</p>
    <p>The `@prnt` operation is a macro, created by invoking `@wksht`, wrapping the `@pprint` Domain-Specific Language.</p>
    <p>The use of the metaprogramming operator will be explained later. We must discuss some pre-requisite concepts first.</p>
    <hr>
    <center>
    <h2 id="codegen">codegen</h2>
    </center>
    <hr>
    <p>Seabass allows you to define functions and variables which exist exclusively at compiletime, i.e., while the `cbas` tool is running. <b>They do not exist in the final compiled program.</b></p>
    <p>These "symbols" are annotated as such using the `codegen` keyword.</p>
    <p>codegen functions may access special `builtin` functions of the `cbas` tool, giving it access to the internals of the compiler, the filesystem, compiletime memory allocation, and etcetera.</p>
    <p>codegen functions are invoked from any of the following:</p>
    <ol>
        <li>Called from another codegen function</li>
        <li>a "parsehook invocation" (using the metaprogramming operator- @)</li>
        <li>the "#__cbas_run_fn" directive.</li>
        <li>After parsing is finished, `codegen_main` is executed.</li>
    </ol>
    <p>All of this happens during execution of `cbas` on a translation unit.</p>
    
    <hr>
    <center>
    <h2 id="codegenmain">codegen_main</h2>
    </center>
    <hr>
    <p>As mentioned <a href="#whatis">before</a> , Seabass is self-retargeting. It allows you to define a function which is responsible for generating the "output" of the compiler.</p>
    <p>In the fibonacci number program from the <a href="#basicsyntaxc">previous section</a>, it was used to generate C code. This C code would then be compiled with a C compiler to generate an executable binary.</p>
    <p>codegen_main is only special in that the `cbas` tool will attempt to find it inside the translation unit after parsing has finished. If it cannot find it, it will print out the parsed AST and then exit.</p>
    <p>In principle, the codegen_main function can generate arbitrary output. It is fully programmable.</p>
    <p>If you should desire to use Seabass as a scripting language, it is possible to write entire programs purely within the confines of `codegen` code, and use the `cbas` tool like a script interpreter. This functionality was used to develop and debug the original implementation.</p>
    <hr>
    <center>
    <h2 id="parsehooks">parsehooks</h2>
    </center>
    <hr>
    <p><i>We are now ready to discuss what the @ sign does.</i></p>
    <p>In seabass, you can write special codegen functions which can be invoked with the metaprogramming operator. Here is how you declare and use one:</p>
    <pre><code>
    proc codegen parsehook_dostuff():
        __builtin_puts("Hello, World!");
    end
    //invocation...
    @dostuff
    </code></pre>
    <p><i>(Note that 'proc' is just an alias for 'fn')</i></p>
    <p>When the parser sees an @ sign followed by an identifier, it looks for a codegen function with that name prefixed by 'parsehook_'. This function is then immediately called. This function can then use builtin functions such as __builtin_peek() to access the tokenized source code of the program and manipulate it. This functionality was used to implement `@wksht` and `@pprint` from <a href="#basicsyntaxc">before</a>.</p>
    <hr>
    <center>
    <h2 id="syntaxsemantics">Syntax Semantics</h2>
    </center>
    <hr>
    <p>You now understand the basics of what makes Seabass unique. 
    However, in order to actually get started programming, you 
    need to understand some of the other features and details 
    of the language.</p>
    <hr>
    <center>
    <h2 id="oop">Object Oriented Programming</h2>
    </center>
    <hr>
    <p>For convenience, Seabass has several features from Object Oriented programming:</p>
    <ol>
        <li>the `class` keyword as an alias for `struct`.</li>
        <li>methods- functions invoked on a struct/class which are specific to that class/struct.</li>
        <li>Automatic constructors and destructors- Functions which are invoked on a struct when it first appears in a scope, and when it disappears.</li>
    </ol>
    <p>Here is a small example program (using entirely codegen code) which demonstrates object oriented programming in Seabass:</p>
    <pre><code>
    /*
        Small program to demonstrate object oriented programming in Seabass.
    */
    
    class myClass
        noexport
        int a
        char* b
    end
    
    codegen int a = 25;
    
    method codegen myClass.ctor():
        this.a = a++;
        char[500] buf
        __builtin_itoa(buf, this.a);
        this.b = __builtin_strdup(buf);
        __builtin_puts("I have been constructed! My string is...");
        __builtin_puts(this.b);
    end
    
    method codegen myClass.dtor():
        __builtin_puts("Goodbye! My string was...");
        __builtin_puts(this.b);
        __builtin_free(this.b);
        a--
    end
    
    method codegen myClass.print():
        __builtin_puts(this.b)
    end
    
    fn codegen codegen_main():
    
        i64 i
        for(i = 0, i < 10; i++)
            myClass qq
            myClass qq2
            myClass qq3
            myClass qq4
            qq3.print()
            if(i == 3) continue end
            qq2.print()
        end
        
        if(1)
            //demo move...
            myClass qq
            myClass qq2
            __builtin_free(qq.b); //ensure we don't leak memory...
            qq := qq2;
            qq2.b = __builtin_strdup("I seem to have lost my old string...");
            qq.print();
            qq2.print();
        end
        return	
    end
    </code></pre>
    <p>As you can see, `.ctor()` and `.dtor()` are methods on the `myClass` type. The `ctor` method is invoked at instantiation, and the `dtor` method is invoked when the object is destroyed. `continue` properly causes objects within a loop body to be destroyed.</p>
    <p>.ctor() and .dtor() methods are NOT automatically called under these circumstances:</p>
    <ol>
        <li>When an array of objects is declared</li>
        <li>When objects are declared at global scope</li>
        <li>When a pointer to an object is declared</li>
        <li>When an object is inside of another object</li>
    </ol>
    <p>You must be especially careful of 4- Seabass will <b>not</b> automatically write constructors and destructors for you, nor automatically insert invocations of member object constructors/destructors. You must write the constructors and destructors for your objects yourself, constructing and destroying member objects where appropriate.</p>
    <p><i>[Note, of course, that because Seabass is a metaprogramming language, it is possible to write languages within Seabass that do not have these limitations...]</i></p>
    <p>Also note that seabass does not have any of the following from object oriented programming:</p>
    <ol>
        <li>Inheritance</li>
        <li>Virtual methods</li>
        <li>Operator overloading</li>
    </ol>
    <p>It <i>does</i> have move semantics. There is a dedicated "move" operator, <code>:=</code> which copies one pointed-to object into another.</p>
    <hr>
    <center>
    <h2 id="pointers">Pointer Semantics</h2>
    </center>
    <hr>
    <p>The syntax of Seabass differs from C most in its usage of pointers. Note the following:</p>
    <ol>
        <li>It is not possible to get the address of local primitive variables. You may not use the `&` operator to take the address of a variable. Taking the address of global variables is done with `getglobalptr`.</li>
        <li>There are no function pointers in the type system- all function pointers are `byte*`. They are obtained with `getfnptr` and used with `callfnptr`.</li>
        <li>Structs never appear by-value in an expression.</li>
        <li>Indexing an array of pointer-to-struct will yield a pointer-to-struct rather than an lvalue struct.</li>
        <li>Just like C, arrays decay into pointers in an expression.</li>
        <li>Seabass has a dedicated `memcpy` operator, called the `move` operator, <code>:=</code>.</li>
        <li>Seabass has two dedicated C-string comparison operators, `streq` and `strneq`.</li>
    </ol>
    <p>For C programmers, this means all of the following:</p>
    <ol>
        <li>In order to pass a pointer to a primitive variable (such as passing int* len into a buffer-filling function) you should declare an array of length one. I.e. in C you would do this....
        <pre><code>
        void myfunction(char* buf, int* lenout);
        
        /*usage...*/
        int lenout;
        char buf[256];
        myfunction(buf, &lenout);
        </code></pre>
        But you would do this in Seabass:
        <pre><code>
        fn myfunction(char* buf, int* lenout);
        
        //usage...
        int[1] lenout;
        char[256] buf;
        myfunction(buf, lenout);
        </code></pre>
        (please also note that seabass places array length <i><b>next to the type</b></i> and not next to the variable name).
        </li>
        <li>Passing structs by-value is not possible in Seabass. 
        If you want to pass an object into a function in seabass, 
        you pass a pointer to that object. 
        That function can then make a separate copy if it so desires. 
        <i>Please note that if pass-by-value is performance-critical 
        to your application, it can still be achieved with inline target code.</i>.
        </li>
        <li>Use of <code>strcmp(a,b)==0</code> is outmoded in Seabass. 
        You do <code>a streq b</code>.
        </li>
        <li>If you have an array of structs like so...
        <pre><code>
        struct mystruct
            mystruct* c
            char[1<<6] name
            int a
            i32 b
        end
        mystruct[12*50/2] myarray;
        </code></pre>
        Then <code>myarray[27]</code> is semantically sequivalent to <code>(myarray + 27)</code>. A struct type <i>never</i> appears by-value in an expression.

        </li>
        <li>
        Function pointer syntax has been changed. An example:
        <pre><code>
        //function whose pointer we take...
        fn myfunction(int a, char* text)->float;
        
        //this function's prototype is used....
        fn noexport template_function(int q, char* t)->float;
        
        //retrieve a pointer to `myfunction`
        byte* mypointer = getfnptr(myfunction);
        
        //call the function...
        float x = callfnptr[template_function](mypointer)(3, "Hello World!");
        </code></pre>
        </li>
        <li>Assignment between structs is done using the `move` operator:
        <pre><code>
        struct mystruct
            mystruct* c
            char[1<<6] name
            int a
            i32 b
        end
        
        mystruct a
        mystruct b
        
        //later....
        
        //a = b; //ERROR!
        a := b; //correct
        </code></pre>
        The move operator can of course be used on any pointers of compatible type, not just pointers to structs...
        <pre><code>
        //'array of pointer to int'
        int*[530] a;
        //'pointer to int'
        int* b;
        
        
        //later...
        
        /*
        *copy the object pointed to by b into the
        *object pointed to by the 20th element of a
        */
        a[20] := b;
        </code></pre>
        
        </li>
    </ol>
    <hr>
    <center>
    <h2 id="tailcall">Tail Calls</h2>
    </center>
    <hr>
    <p>Seabass allows any function to "tail call" another- i.e., it will 'jump' to that function.</p>
    <p>This is particularly useful for implementing some kinds of algorithms.</p>
    <p>Tail calls are only valid between two functions with the same prototype. I.e.- this is valid-</p>
    <pre><code>
        fn tailtome(i32 a, byte b)->f32;
        fn myfunction(int a, char b)->float:
            tail tailtome //prototype is identical (i32,u8)->f32
        end
    </code></pre>
    <p>But this is not:</p>
    <pre><code>
        fn tailtome(i32 a, byte b)->f32;
        fn myfunction2(int a, int b)->int:
            tail tailtome //ERROR: prototype does not match! (i32,i32)->i32 != (i32,u8)->f32
        end
    </code></pre>
    <p>because myfunction2 does not have an identical prototype to `tailtome`.</p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <hr>
    <center>
    <h2 id="typedecl">Type Declarations</h2>
    </center>
    <hr>
    <p>In seabass, a type always follows this pattern:</p>
    <p><code>typename********[constexpr]</code></p>
    <p>Namely, a single identifier ('typename') followed by zero or more stars and an optional 'bracketed portion' denoting an array length.</p>
    <p>Type declarations are used in the following locations:</p>
    <ol>
        <li>To declare variables:
        <pre><code>
        int my_int;
        int* my_pointer_toint;
        int[50] my_array_of_50_ints;
        int*[10*5] my_array_of_50_pointers_to_ints;
        mystruct my_struct_variable;
        mystruct[5] my_array_of_5_struct_variables;
        mystruct******[1<<13] Can_you_guess;
        </code></pre>

        </li>
        <li>In sizeof().
        <pre><code>
        sizeof(mystruct***[50])
        </code></pre>
        <i>Note that this is the only valid use of sizeof. You may not put variable names or expressions inside of sizeof.</i>
        </li>
        <li>In the data statement. Note that you may not declare a data statement of pointers, arrays, or structs.
            <pre><code>
        data codegen int myintegers 5,3,1<<2;
            </code></pre>
            <i>The data statement will be discussed in more detail later.</i>
        </li>
        <li>In the prototype of functions and methods.
            <pre><code>
        fn myfunction(int a, char* b)->mystruct;
            </code></pre>        
            Note the following "gotchas":
            <ul>
                <li>All references to non-pointer structs will be converted to pointer-to-struct. I.e., the following declarations are identical:<br><br>
                    <code>procedure myproc(mystruct a)->mystruct;</code><br>
                    <code>function myproc(mystruct* a)->mystruct;</code><br>
                    <code>func myproc(mystruct a)->mystruct*;</code><br>
                    <code>proc myproc(mystruct* a)->mystruct*;</code><br>
                    <br>
                    <br>
                </li>
                <li>You may not pass an array into a function or return it. These are syntax errors:
                    <br>
                    <br>
                    <code>proc myproc(int[50] a)->int;</code><br>
                    <code>fn myproc(int a)->int[50];</code><br>
                    <br>
                    <br>
                </li>
            </ul>
        </li>
    </ol>
    <hr>
    <center>
    <h2 id="typealiases">Type Alias List</h2>
    </center>
    <hr>
    <p>Here is a list of all primitive types, and their aliases.</p>
    <pre><code>
        u8 - char - uchar - byte - ubyte
        i8 - schar - sbyte
        u16 - ushort
        i16 - short - sshort
        u32 - uint - ulong
        i32 - int - sint - long - slong
        u64 - ullong - qword - uqword
        i64 - llong - sllong - sqword - uptr
        f32 - float
        f64 - double
    </code></pre>
    <p><i>Note that pointers are also considered primitive.</i></p>
    <p>structs, classes, and unions are *not* considered primitive.</p>
    <p>Note that `void`, while it exists in the type system, <i>does not have a keyword in the language</i>. Seabass uses `byte*` instead of `void*`.</p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <hr>
    <center>
    <h2 id="keywords">Keyword List</h2>
    </center>
    <hr>
    <p>Please note that aliases are listed on the same line separated by hyphens.</p>
    <h3>Keywords</h3>
    <pre><code>
    fn - function - func - procedure - proc
    cast
    u8 - char - uchar - byte - ubyte
    i8 - schar - sbyte
    u16 - ushort
    i16 - short - sshort
    u32 - uint - ulong
    i32 - int - sint - long - slong
    u64 - ullong - qword - uqword
    i64 - llong - sllong - sqword - uptr
    f32 - float
    f64 - double
    noexport
    break
    data
    string
    end
    continue
    if
    elif - elseif
    else
    while
    for
    goto - jump
    switch
    return
    tail
    sizeof
    static
    pub - public
    predecl
    struct - class
    union
    method
    codegen
    constexpri
    constexprf
    pure
    inline
    atomic
    volatile
    getfnptr
    callfnptr
    getglobalptr
    asm
    </code></pre>
    <h3>Operators</h3>
    <p>Please note that aliases are listed on the same line separated by commas.</p>
    <pre><code>
    ++
    --
    :=
    :
    <=
    <
    >=
    >
    != , neq
    == , === , eq
    ->
    .&
    &
    &&
    |
    ||
    >>
    <<
    ~
    !
    .
    &
    *
    +
    -
    /
    %
    <
    >
    ^
    |
    ? //unused
    =
    @
    streq
    strneq
    </code></pre>
    <p><i>Note that comma is *NOT* an operator.</i></p>
    <h3>Special Reserved Characters and sequences</h3>
    <pre><code>
    "string literals"
    '\n'
    #
    #include ""
    #include <>
    #define
    #undef
    #guard
    ,
    ;
    </code></pre>
    <h3>String literal and character literal escape sequences</h3>
    <pre><code>
    \a - ASCII 0x7
    \b - ASCII 0x8
    \e - ASCII 0x1B
    \f - ASCII 0xC
    \n - ASCII 0xA
    \r - ASCII 0xD
    \t - ASCII 0x9
    \v - ASCII 0xB
    //the following escape sequences simply emit the second character.
    \\ - ASCII 0x5C
    \' - ASCII 0x27
    \" - ASCII 0x22
    \? - ASCII 0x3F
    </code></pre>
    <hr>
    <center>
    <h2 id="gotolabels">Labels</h2>
    </center>
    <hr>
    <p>Seabass declares goto labels with a colon at the beginning rather than the end:</p>
    <p><code>:mylabel</code></p>
    <p><code>:mylabel2</code></p>
    <p><code>:my_really_long_labelname</code></p>
    <p>They are used by `goto`/`jump` and `switch`.</p>
    <p><code>goto my_really_long_labelname</code></p>
    <p><code>jump my_really_long_labelname</code></p>
    <p><code>switch(1+1) mylabel mylabel2 my_really_long_labelname;</code></p>
    <p>Note that goto may not enter a scope, It can only jump within its own scope or a parent scope.</p>
    <pre><code>
    goto mylabel1 //ERROR
    goto mylabel2 //ERROR
    goto mylabel2_5 //ERROR
    goto mylabel3 //ERROR
    goto mylabel4 //OK
    if(1)
        jump mylabel1 //OK

        :mylabel1

        jump mylabel3 //OK
        goto mylabel4 //OK
        goto mylabel2 //ERROR
        jump mylabel2_5 //ERROR
        if(1)
            :mylabel2
            goto mylabel1   //OK
            goto mylabel2   //OK
            jump mylabel3   //OK
            goto mylabel4   //OK
            goto mylabel2_5 //ERROR
        elif(1)
            goto mylabel1   //OK
            goto mylabel2   //ERROR
            goto mylabel2_5 //OK
            jump mylabel3   //OK
            goto mylabel4   //OK
            :mylabel2_5
            jump mylabel1   //OK
            jump mylabel2   //ERROR
            jump mylabel2_5 //OK
            jump mylabel3   //OK
            goto mylabel4   //OK
        end
        :mylabel3
        jump mylabel1 //OK
        jump mylabel2 //ERROR
        jump mylabel2_5 //ERROR
        goto mylabel3 //OK
        jump mylabel4 //OK
    end
    :mylabel4
    </code></pre>
    <p></p>
    <p></p>
    <p></p>

    <hr>
    <center>
    <h2 id="switch">Switch Statement</h2>
    </center>
    <hr>
    <p>Seabass has a switch statement that works very differently from C. It is a pure unchecked dispatch table. It accepts an expression (delimited by parentheses) and then a sequence of goto labels. You may optionally insert commas between the labels.</p>
    <p>Depending on the value of the expression, the switch statement will jump to one of the entries in the list.</p>
    <pre><code>
        u64 v = cast(u64)get_user_input("Please enter an integer:") % 10;
        switch(v) is0, is1, is2, is3, is4, is5, is6, is7, is8, is9, is10;
        :is0
            println("Got 0!");
            goto after
        :is1
            println("Got 1!");
            goto after
        :is2
            println("Got 2!");
            goto after
        :is3
            println("Got 3!");
            goto after
        :is4
            println("Got 4!");
            goto after
        :is5
            println("Got 5!");
            goto after
        :is6
            println("Got 6!");
            goto after
        :is7
            println("Got 7!");
            goto after
        :is8
            println("Got 8!");
            goto after
        :is9
            println("Got 9!");
        :after
        println("Goodbye!")
        sys_exit(0);
    </code></pre>
    <p>The labels in a switch statement must all be in the same scope as the switch statement- it is not valid for them to be in a parent or child scope. Also note that switch statements in seabass are <i>unchecked</i> meaning that invalid values (negative or >= number of labels in the statement) will result in <b><i>undefined behavior</i></b>.</p>
    <pre><code>
    :lab0
    switch(1) lab0, lab8, lab9; //OK, goto lab8
    switch(7) lab0, lab8, lab9; //UNDEFINED BEHAVIOR
    switch(1) lab0, lab1, lab2; //ERROR!
    for(1,1,1)
        :lab1
        :lab2
        switch(0) lab0, lab8, lab9; //ERROR!
        switch(3) lab1 lab2 lab5 lab6 lab7; //OK, goto lab6
        switch(3) lab1 lab2, lab5; //UNDEFINED BEHAVIOR
        switch(1) lab1, lab2, lab3, lab4; //ERROR!
        if(1)
            :lab3
            :lab4
            switch(1) lab3, lab4; //OK, goto lab4
            switch(1) lab1 lab2; //ERROR!
        end
        :lab5
        :lab6
        switch(1) lab1 lab2 lab5 lab6 lab7; //OK, goto lab2
        :lab7
    end
    :lab8
    :lab9
    switch(2) lab0, lab8, lab9; //OK, goto lab9
    </code></pre>
    <p><i>Please study the example above carefully</i></p>
    <p></p>
    <p></p>
  </body>
</html>


