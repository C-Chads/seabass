
#include "cg_uast_common.hbas"

/*
    PLAN: Template a 
*/
codegen u64 testbench_block = 0xff01;
codegen u64 testbench_stmt = 0xff02;
codegen u64 testbench_expr = 0xff03;
codegen u64 testbench_pstmt = 0xff04;
codegen u64 testbench_expr_terminal = 0xff05;
fn codegen testbench_print_ast(cg_uast uast, u64 nid):
    cg_uastnode* pp = uast.nodes[nid];
    cgstrll* ppn;
    if(pp.coord == testbench_block)
        ppn = (cgstrll*) pp.udata;
        @pprint[
            /       "BEGIN BLOCK"
            /       (ppn.text)
        ]
    elif(pp.coord == testbench_pstmt)
        @pprint[
            /       "BEGIN PSTMT"
        ]
    elif(pp.coord == testbench_expr)
        ppn = (cgstrll*) pp.udata;

        @pprint[
            /       "EXPR"
            /       (ppn.text)
        ]    
    elif(pp.coord == testbench_expr_terminal)
        @pprint[
            /       "EXPR_TERM"
            /       (pp.udata)
        ]
        __builtin_free(pp.udata)
    end
    u64 i
    for(i = 0, i < pp.n_rel, i++)
        testbench_print_ast(uast, pp.rel[i]);
    end
    :skipugly
    if(pp.coord == testbench_block)
        @pprint[
            /       "END BLOCK"
            /       (ppn.text)
        ]
        __builtin_free(ppn.text);
        __builtin_free(pp.udata);
    elif(pp.coord == testbench_pstmt)
        @pprint[
            /       "END PSTMT"
        ]
    elif(pp.coord == testbench_expr)
        @pprint[
            /       "END EXPR"
            /       (ppn.text)
        ]
        __builtin_free(ppn.text);
        __builtin_free(pp.udata);
    end
end
@cgrdparser[
    testbench[
        cg_uast uast
        char* errtext
        u64 rid
    ]
    head[
        this.uast.ctor();
        do err_on_null
        //we need to push a dummy token...
        cg_uastnode rootnode
        rootnode.udata = "__ROOT__"; //don't free this...
        rootnode.coord = cg_uast_coord_root_node;
        this.rid = this.uast.push_node(rootnode);
        this.uast.stackpush(this.rid);
        
        //a "program" consists entirely of a single block...
        do block
        u64 qq = this.uast.stackpop();
        this.uast.add_link(this.rid, qq);
        finish
    ]
    @linseq[
        block
        [IDENT] "{" stmts "}" : (testbench_block)
    ]
    /*
    block_old[ //parse a block..
        cg_uastnode me
        u64 nid
        u64 pid
        me.coord = testbench_block;
        do err_on_null
        if(tok.d != CG_TOK_IDENT) this.errtext = "Block expected identifier- name"; go err end
        me.udata = __builtin_strdup(tok.text);
        eat
        do err_on_null

        match[["{"]
            eat
        else
            this.errtext = "Block expected Opening curly brace"; 
            go err                
        ]


        nid = this.uast.push_node(me);
        pid = this.uast.pstack[this.uast.stackptr-1];
        this.uast.add_link(pid,nid);
        this.uast.stackpush(nid); //push ourselves onto the stack...
            do err_on_null
            do stmts
            do err_on_null
        this.uast.stackpop(); //pop ourselves off the stack..
        while(1)
            match[["}"]
                eat
                break
            ]
            this.errtext = "Block expected closing curly brace..."; 
            go err
        end
        //we have finished this block!
    ]
    */
    stmts[
        //ON ENTRY: WE ARE INSIDE OF A BLOCK...
        while(1)
            do err_on_null
            do stmt
            match[["}"]
                finish
            ]
        end
    ]
    stmt[ //parse a stmt
        char* ident_text
        i64 kind = 0;
        u64 pid;
        u64 nid;
        do err_on_null
        if(tok.text!=0)
        end
        while(1)
            match[[";"]
                eat
                kind = 0
                break
            ]
            match[["p"]
                eat
                kind = 1
                break
            ]
            match[["}"]
                finish
            ]
            if(tok.d == CG_TOK_IDENT)
                kind = 2
                break
            end
            this.errtext = "Unknown stmt type"; 
            go err
        end
        switch(kind) nothing print blk;
        this.errtext = "Internal error"; go err ;
        :print
            //
            pid = this.uast.pstack[this.uast.stackptr-1];
            do pstmt
            nid = this.uast.stackpop();
            this.uast.add_link(pid, nid);
        finish
        :nothing
        finish
        :blk
            pid = this.uast.pstack[this.uast.stackptr-1];
            do block
            nid = this.uast.stackpop();
            this.uast.add_link(pid, nid);
        finish
    ]
    pstmt[
        cg_uastnode me
        u64 nid
        me.coord = testbench_pstmt;
        me.udata = 0;
        nid = this.uast.push_node(me);
        this.uast.stackpush(nid);
        //don't even bother pushing ourselves onto the stack...
        while(1)
            do err_on_null
            match[[";"]eat break]
            match[["}"]break]
            match[[","]eat continue]
            do expr
            //pop off the stack..
            u64 eid = this.uast.stackpop();
            this.uast.add_link(nid,eid);
            match[[","]eat continue]
            match[[";"]eat break]
            match[["}"]break]
            this.errtext = "Expected comma"
        end
        //add ourselves to our parent node..
        /*
        u64 pid = this.uast.pstack[this.uast.stackptr-1];
        this.uast.add_link(pid, nid);
        */
        //continue...
    ]
    expr[
        go this_is_something
    ]
    @binop_linseq[
        this_is_something
        leftassoc
        this_was_a_something "THIS" "IS" [IDENT] prefix : (testbench_expr)
    ]
    @binop_linseq[
        this_was_a_something
        leftassoc
        this_was_something "THIS" "WAS" "=" [IDENT] prefix : (testbench_expr)
    ]
    @binop_linseq[
        this_was_something
        leftassoc
        logbool "THIS" "WAS" [IDENT] prefix : (testbench_expr)
    ]
    @binop[
        logbool
        addsub "&&" "||" logbool : (testbench_expr)
    ]
    @binop[
        addsub
        leftassoc
        muldiv "+" "-" muldiv : (testbench_expr)
    ]
    @binop[
        muldiv
        leftassoc
        prefix "*" "/" prefix : (testbench_expr)
    ]
    @cond[
        prefix
        d![CG_TOK_STRING]text["-"]?prefix_minus
        d[CG_TOK_OPERATOR]text["~"]?prefix_compl
        if[1]? terminal
        else terminal
    ]
    prefix_minus[
        cg_uastnode me
        u64 nid
        do err_on_null

        eat
        cgstrll* qq = (cgstrll*)__builtin_malloc(sizeof(cgstrll));
        qq.text = __builtin_strdup("unary-");
        qq.d = CG_TOK_STRING; //only valid...
        me.udata = (u8*)qq;
        me.coord = testbench_expr;
        nid = this.uast.push_node(me);
        //do prefix again...
        do prefix
        //get the node from it
        u64 cid = this.uast.stackpop();
        //add a link between our node and that node...
        this.uast.add_link(nid,cid);
        //push ourselves and finish...
        this.uast.stackpush(nid);
        finish
    ]    
    prefix_compl[
        cg_uastnode me
        u64 nid
        do err_on_null

        eat
        cgstrll* qq = (cgstrll*)__builtin_malloc(sizeof(cgstrll));
        qq.text = __builtin_strdup("unary~");
        qq.d = CG_TOK_STRING; //only valid...
        me.udata = (u8*)qq;
        me.coord = testbench_expr;
        nid = this.uast.push_node(me);
        //do prefix again...
        do prefix
        //get the node from it
        u64 cid = this.uast.stackpop();
        //add a link between our node and that node...
        this.uast.add_link(nid,cid);
        //push ourselves and finish...
        this.uast.stackpush(nid);
        finish
    ]
    terminal[
        //number only!
        do err_on_null
        if(tok.d != CG_TOK_INT_CONST) this.errtext = "Expected integer constant..."; go err end
        //get the contents of the token...
        u64 nid
        cg_uastnode me
        me.udata = __builtin_strdup(tok.text);
        me.coord = testbench_expr_terminal;
        eat //don't forget to eat it!!!
        
        nid = this.uast.push_node(me);
        this.uast.stackpush(nid);
    ]
    //error handling..
    err_on_null[
        if(tok != 0) finish end
        this.errtext = "Early end of compilation unit...";
        go err
    ]
    err[
        @pprint[
            /bar
            /       "Testbench language error!"
            /bar
            /       (this.errtext)
            /       "Does that help you? No line numbers implemented, unfortunately. Quitting..."
        ]
        if(tok != 0)
        
            @pprint[
                /   "Here's the contents of tok:debug_print() at the time of the error:"
            ]
            tok:debug_print();
        end
        __builtin_exit(1);
    ]
    finish[
        emitq ";"
        testbench_print_ast(this.uast, this.uast.nodes[this.rid].rel[0]);
        this.uast.dtor();
        finish
    ]
]

@testbench[
    bigBlock{
        p 7,3,5-9/3*71*4*5*6;
        littleblock{
            p 7,3,5-9/3;
        
        }
        badblock{
            p 7,15 * -3;
            p 7+1 || 0 THIS WAS = A_FUZZY_WUZZY -~- -~1;
        }
    }
]




function codegen codegen_main():
    
end
