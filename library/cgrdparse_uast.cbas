
#include "cg_uast_common.hbas"

/*
    PLAN: Template a 
*/
codegen u64 testbench_block = 0xff01;
codegen u64 testbench_stmt = 0xff02;
codegen u64 testbench_expr = 0xff03;
codegen u64 testbench_pstmt = 0xff04;
codegen u64 testbench_expr_terminal = 0xff05;
codegen u64 testbench_expr_parenthesized = 0xff06;
codegen u64 testbench_expr_pre = 0xff07;
fn codegen testbench_print_ast(cg_uast uast, u64 nid):
    cg_uastnode* pp = uast.nodes[nid];
    cgstrll* ppn;
    if(pp.coord == testbench_block)
        ppn = (cgstrll*) pp.udata;
        @pprint[
            /       "BEGIN BLOCK"
            /       (ppn.text)
        ]
    elif(pp.coord == testbench_pstmt)
        @pprint[
            /       "BEGIN PSTMT"
        ]
    elif(pp.coord == testbench_expr)
        ppn = (cgstrll*) pp.udata;

        @pprint[
            /       "EXPR"
            /       (ppn.text)
        ]        
    elif(pp.coord == testbench_expr_pre)
        ppn = (cgstrll*) pp.udata;
        @pprint[
            /       "EXPR_PREFIX"
            /       (ppn.text)
        ]    
    elif(pp.coord == testbench_expr_terminal)
        ppn = (cgstrll*) pp.udata;
        @pprint[
            /       "EXPR_TERM"
            /       (ppn.text)
        ]
        __builtin_free(ppn.text);
        __builtin_free((u8*)ppn);
    end
    u64 i
    for(i = 0, i < pp.n_rel, i++)
        testbench_print_ast(uast, pp.rel[i]);
    end
    :skipugly
    if(pp.coord == testbench_block)
        @pprint[
            /       "END BLOCK"
            /       (ppn.text)
        ]
        __builtin_free(ppn.text);
        __builtin_free(pp.udata);
    elif(pp.coord == testbench_pstmt)
        @pprint[
            /       "END PSTMT"
        ]
    elif(pp.coord == testbench_expr)
        @pprint[
            /       "END EXPR"
            /       (ppn.text)
        ]
        __builtin_free(ppn.text);
        __builtin_free(pp.udata);    
    elif(pp.coord == testbench_expr_pre)
        @pprint[
            /       "END EXPR_PREFIX"
            /       (ppn.text)
        ]
        __builtin_free(ppn.text);
        __builtin_free(pp.udata);
    end
end
@cgrdparser[
    testbench[
        cg_uast uast
        char* errtext
        u64 rid
    ]
    head[
        this.uast.ctor();
        do err_on_null
        //we need to push a dummy token...
        cg_uastnode rootnode
        rootnode.udata = "__ROOT__"; //don't free this...
        rootnode.coord = cg_uast_coord_root_node;
        this.rid = this.uast.push_node(rootnode);
        this.uast.stackpush(this.rid);
        
        //a "program" consists entirely of a single block...
        do block
        u64 qq = this.uast.stackpop();
        this.uast.add_link(this.rid, qq);
        finish
    ]
    @linseq[
        block
        [IDENT] "{" stmts "}" : (testbench_block)
    ]
    @repseq[
        stmts
        noconsume
        ["}"]
        X stmt X
    ]
    stmt[ //parse a stmt
        char* ident_text
        i64 kind = 0;
        u64 pid;
        u64 nid;
        do err_on_null
        if(tok.text!=0)
        end
        while(1)
            match[[";"]
                eat
                kind = 0
                break
            ]
            match[["p"]
                eat
                kind = 1
                break
            ]
            match[["}"]
                finish
            ]
            if(tok.d == CG_TOK_IDENT)
                kind = 2
                break
            end
            this.errtext = "Unknown stmt type"; 
            go err
        end
        switch(kind) nothing print blk;
        this.errtext = "Internal error"; go err ;
        :print
            //
            pid = this.uast.pstack[this.uast.stackptr-1];
            do pstmt
            nid = this.uast.stackpop();
            this.uast.add_link(pid, nid);
        finish
        :nothing
        finish
        :blk
            pid = this.uast.pstack[this.uast.stackptr-1];
            do block
            nid = this.uast.stackpop();
            this.uast.add_link(pid, nid);
        finish
    ]
    pstmt[
        cg_uastnode me
        u64 nid
        me.coord = testbench_pstmt;
        me.udata = 0;
        nid = this.uast.push_node(me);
        this.uast.stackpush(nid);
        
        do exprs_in_pstmt
        finish
    ]
    @repseq[
        exprs_in_pstmt
        [";"]
        X get_expr_push_onto_pstmt X "," X
    ]
    get_expr_push_onto_pstmt[
        //
        u64 nid = this.uast.pstack[this.uast.stackptr-1];
        
        do expr
        //pop off the stack..
        u64 eid = this.uast.stackpop();
        this.uast.add_link(nid,eid);
    ]
    expr[
        go this_is_something
    ]
    @binop_linseq[
        this_is_something
        leftassoc
        this_was_a_something "THIS" "IS" [IDENT] prefix : (testbench_expr)
    ]
    @binop_linseq[
        this_was_a_something
        leftassoc
        this_was_something "THIS" "WAS" "=" [IDENT] prefix : (testbench_expr)
    ]
    @binop_linseq[
        this_was_something
        leftassoc
        logbool "THIS" "WAS" [IDENT] prefix : (testbench_expr)
    ]
    @binop[
        logbool
        addsub "&&" "||" logbool : (testbench_expr)
    ]
    @binop[
        addsub
        leftassoc
        muldiv "+" "-" muldiv : (testbench_expr)
    ]
    @binop[
        muldiv
        leftassoc
        prefix "*" "/" prefix : (testbench_expr)
    ]
    @cond[
        prefix
        d[CG_TOK_OPERATOR]text["-"]?prefix_single_token_universal
        d[CG_TOK_OPERATOR]text["~"]?prefix_single_token_universal
        //if[tok!=0 && tok.d == CG_TOK_OPERATOR && tok.text streq "~"]?prefix_compl
        //if[1]? terminal
        else terminal
    ]
    @linseq[
        prefix_single_token_universal
        [OP] prefix^ : (testbench_expr_pre)
    ]
    @cond[
        terminal
        d[CG_TOK_OPAREN]?parenthesized_expr
        else terminal_number
    ]
    @linseq[
        parenthesized_expr
        "(" expr^ ")" : (testbench_expr_parenthesized)
    ]
    @linseq[
        terminal_number
        [NUM] : (testbench_expr_terminal)
    ]
    //error handling..
    err_on_null[
        if(tok != 0) finish end
        this.errtext = "Early end of compilation unit...";
        go err
    ]
    err[
        @pprint[
            /bar
            /       "Testbench language error!"
            /bar
            /       (this.errtext)
            /       "Does that help you? No line numbers implemented, unfortunately. Quitting..."
        ]
        if(tok != 0)
            @pprint[
                /   "Here's the contents of tok:debug_print() at the time of the error:"
            ]
            tok:debug_print();
        end
        __builtin_exit(1);
    ]
    finish[
        emitq ";"
        testbench_print_ast(this.uast, this.uast.nodes[this.rid].rel[0]);
        this.uast.dtor();
        finish
    ]
]

@testbench[
    bigBlock{
        p 7,3,5-(9)/3*71*4*5*6;
        littleblock{
            p 7,3,5-9/3;
        
        }
        badblock{
            p 7,15 * -3;
            p 7+1 || 0 THIS WAS = A_FUZZY_WUZZY -~- -~1.5e1;
        }
        goodblock{
            ;;;;;
            p 1.3e7, 22 THIS WAS = VERY_VERY_GOOD -(5*3);
        }
    }
]




function codegen codegen_main():
    
end
