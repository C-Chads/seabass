

/*
    USER-MODE STANDARD LIBRARY FOR SEABASS- BASIC INTERFACE.
    
    Should provide the basic functionality...
    
    Make sure to include a bitXX.hbas file...
    
    such as bit64.hbas or bit32.hbas
*/

#guard SEABASS_STDLIB_GNUC

//The glories of a multi-line string literal!
data codegen string SEABASS_STDLIB_PREFIX "
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include <errno.h>
//IMPLEMENTER'S NOTE: Change this define based on the target...
#define i32 int

#ifndef __APPLE__
#include <pthread.h>
typedef struct {
	pthread_mutex_t myMutex;
	pthread_barrier_t myBarrier;
	pthread_t myThread;
	int isThreadLive;
	int shouldKillThread;
	int state;
	void (*execute)(unsigned char*);
	unsigned char* argument;
} lsthread;
static inline void init_lsthread(lsthread* t);
static inline void start_lsthread(lsthread* t);
static inline void kill_lsthread(lsthread* t);
static inline void destroy_lsthread(lsthread* t);
static inline void lock(lsthread* t);
static inline void step(lsthread* t);
static void* lsthread_func(void* me_void);

//function declarations

static inline void init_lsthread(lsthread* t){
	//t->myMutex = (pthread_mutex_t)PTHREAD_MUTEX_INITIALIZER;
	pthread_mutex_init(&t->myMutex, NULL);
	pthread_barrier_init(&t->myBarrier, NULL, 2);
	t->isThreadLive = 0;
	t->shouldKillThread = 0;
	t->state = 0;
	t->execute = NULL;
	t->argument = NULL;
}
static inline void destroy_lsthread(lsthread* t){
	pthread_mutex_destroy(&t->myMutex);
	pthread_barrier_destroy(&t->myBarrier);
}
static inline void lock(lsthread* t){
	if(t->state == 1)return;//if already locked, nono
	if(!t->isThreadLive)return;
	pthread_barrier_wait(&t->myBarrier);
	if(pthread_mutex_lock(&t->myMutex))
		exit(1);
	t->state = 1;
}

static inline void step(lsthread* t){
	if(t->state == -1)return; //if already stepping, nono
	if(!t->isThreadLive)return;
	if(pthread_mutex_unlock(&(t->myMutex)))
		exit(1);
	pthread_barrier_wait(&t->myBarrier);
	t->state = -1;
}
static inline void kill_lsthread(lsthread* t){
	if(!t->isThreadLive)return;
	if(t->state != 1){
		lock(t);
	}
	t->shouldKillThread = 1;
	step(t);
	
	pthread_join(t->myThread,NULL);
	
	t->isThreadLive = 0;
	t->shouldKillThread = 0;
}
static void* lsthread_func(void* me_void){
	lsthread* me = (lsthread*) me_void;
	if (!me)pthread_exit(NULL);
	while (1) {
		pthread_barrier_wait(&me->myBarrier);
		pthread_mutex_lock(&me->myMutex);
		if (!(me->shouldKillThread) && me->execute)
			me->execute(me->argument);
		else if(me->shouldKillThread){
			pthread_mutex_unlock(&me->myMutex);
			pthread_exit(NULL);
		}

		pthread_mutex_unlock(&me->myMutex);
		pthread_barrier_wait(&me->myBarrier);
	}
	pthread_exit(NULL);
}
static inline void start_lsthread(lsthread* t){
	if(t->isThreadLive)return;
	t->isThreadLive = 1;
	t->shouldKillThread = 0;
	if(pthread_mutex_lock(&t->myMutex))
		exit(1);
	t->state = 1; //LOCKED
	pthread_create(
		&t->myThread,
		NULL,
		lsthread_func,
		(void*)t
	);
}

#endif

static inline size_t __CBAS__fopen(unsigned char* fname, unsigned char* mode){
    return (size_t)fopen((char*)fname, (char*)mode);
}

static inline i32 __CBAS__fclose(size_t p){
    return fclose((FILE*)p);
}

static inline size_t __CBAS__get_stdout_handle(){
    return (size_t)stdout;
}

static inline size_t __CBAS__get_stdin_handle(){
    return (size_t)stdin;
}

static inline size_t __CBAS__get_stderr_handle(){
    return (size_t)stderr;
}

static inline size_t __CBAS__fwrite(size_t fhandle, unsigned char* buf, size_t nbytes){
    return fwrite(buf, 1, nbytes,(FILE*)fhandle);
}

static inline size_t __CBAS__fread(size_t fhandle, unsigned char* buf, size_t nbytes){
    return fread(buf, 1, nbytes,(FILE*)fhandle);
}

static inline size_t __CBAS__get_utime(){
    return time(0);
}


static inline void __CBAS__set_errno(i32 new_errno){
    errno = new_errno;
}

static inline i32 __CBAS__get_errno(){
    return errno;
}

static inline void __CBAS__mcpy(unsigned char* dst, unsigned char* src, size_t sz){
    memcpy(dst, src, sz);
}
static inline void __CBAS__mmove(unsigned char* dst, unsigned char* src, size_t sz){
    memmove(dst, src, sz);
}

//these are provided for similar reasons...
static inline unsigned char* __CBAS__malloc(size_t amt){
    return malloc(amt);
}

static inline void __CBAS__free(unsigned char* p){
    free(p);
}

static inline unsigned char* __CBAS__realloc(unsigned char* b, size_t amt){
    return realloc(b, amt);
}

static inline void __CBAS__println(unsigned char* s){
    puts((char*)s);
}

static inline void __CBAS__sys_exit(i32 a){
    exit(a);
}

//MATH LIBRARY
//trig
    static inline double __CBAS__sin(double a){
        return sin(a);
    }

    static inline double __CBAS__cos(double a){
        return cos(a);
    }

    static inline double __CBAS__tan(double a){
        return tan(a);
    }

    static inline float __CBAS__sinf(float a){
        return sinf(a);
    }

    static inline float __CBAS__cosf(float a){
        return cosf(a);
    }

    static inline float __CBAS__tanf(float a){
        return tanf(a);
    }

//arcXX functions
    static inline double __CBAS__asin(double a){
        return asin(a);
    }

    static inline double __CBAS__acos(double a){
        return acos(a);
    }

    static inline double __CBAS__atan(double a){
        return atan(a);
    }

    static inline float __CBAS__asinf(float a){
        return asinf(a);
    }

    static inline float __CBAS__acosf(float a){
        return acosf(a);
    }

    static inline float __CBAS__atanf(float a){
        return atanf(a);
    }
//atan2
    static inline double __CBAS__atan2(double a, double b){
        return atan2(a, b);
    }
    static inline float __CBAS__atan2f(float a, float b){
        return atan2f(a, b);
    }
//hyperbolics
    static inline double __CBAS__sinh(double a){
        return sinh(a);
    }
    static inline double __CBAS__cosh(double a){
        return cosh(a);
    }
    static inline double __CBAS__tanh(double a){
        return tanh(a);
    }
//float versions
    static inline float __CBAS__sinhf(float a){
        return sinhf(a);
    }
    static inline float __CBAS__coshf(float a){
        return coshf(a);
    }
    static inline float __CBAS__tanhf(float a){
        return tanhf(a);
    }
//archyperbolics
    static inline double __CBAS__asinh(double a){
        return asinh(a);
    }
    static inline double __CBAS__acosh(double a){
        return acosh(a);
    }
    static inline double __CBAS__atanh(double a){
        return atanh(a);
    }
//float versions
    static inline float __CBAS__asinhf(float a){
        return asinhf(a);
    }
    static inline float __CBAS__acoshf(float a){
        return acoshf(a);
    }
    static inline float __CBAS__atanhf(float a){
        return atanhf(a);
    }
//exp
    static inline double __CBAS__exp(double a){
        return exp(a);
    }
    static inline float __CBAS__expf(float a){
        return expf(a);
    }
    
    static inline double __CBAS__frexp(double a, i32* b){
        int cc = *b;
        double retval = frexp(a,&cc);
        *b = cc;
        return retval;
    }
    static inline float __CBAS__frexpf(float a, i32* b){
        int cc = *b;
        float retval = frexpf(a,&cc);
        *b = cc;
        return retval;
    }
//ldexp 
    static inline double __CBAS__ldexp(double a, i32 b){
        return ldexp(a,b);
    }
    static inline float __CBAS__ldexpf(float a, i32 b){
        return ldexp(a,b);
    }
//logarithms...
    static inline double __CBAS__log(double a){
        return log(a);
    }
    static inline float __CBAS__logf(float a){
        return logf(a);
    }
    static inline double __CBAS__log10(double a){
        return log10(a);
    }
    static inline float __CBAS__log10f(float a){
        return log10f(a);
    }
    static inline double __CBAS__log2(double a){
        return log2(a);
    }
    static inline float __CBAS__log2f(float a){
        return log2f(a);
    }
    static inline double __CBAS__logb(double a){
        return logb(a);
    }
    static inline float __CBAS__logbf(float a){
        return logbf(a);
    }
    static inline double __CBAS__log1p(double a){
        return log1p(a);
    }
    static inline float __CBAS__log1pf(float a){
        return log1pf(a);
    }
//modf
    static inline double __CBAS__modf(double a, double* b){
        return modf(a, b);
    }
    static inline float __CBAS__modff(float a, float* b){
        return modff(a, b);
    }
//exp2
    static inline double __CBAS__exp2(double a){
        return exp2(a);
    }
    static inline float __CBAS__exp2f(float a){
        return exp2f(a);
    }
    static inline double __CBAS__expm1(double a){
        return expm1(a);
    }
    static inline float __CBAS__expm1f(float a){
        return expm1f(a);
    }
//ilogb (RETURNS INT!!!!)
    static inline i32 __CBAS__ilogb(double a){
        return ilogb(a);
    }
    static inline i32 __CBAS__ilogbf(float a){
        return ilogbf(a);
    }
    static inline double __CBAS__scalbn(double a, i32 n){
        return scalbn(a,n);
    }
    static inline float __CBAS__scalbnf(float a, i32 n){
        return scalbnf(a,n);
    }
//pow
    static inline double __CBAS__pow(double a, double b){
        return pow(a, b);
    }
    static inline float __CBAS__powf(float a, float b){
        return powf(a, b);
    }
//sqrt
    static inline double __CBAS__sqrt(double a){
        return sqrt(a);
    }
    static inline float __CBAS__sqrtf(float a){
        return sqrtf(a);
    }
    static inline double __CBAS__cbrt(double a){
        return cbrt(a);
    }
    static inline float __CBAS__cbrtf(float a){
        return cbrtf(a);
    }
//hypot
    static inline double __CBAS__hypot(double a, double b){
        return hypot(a, b);
    }
    static inline float __CBAS__hypotf(float a, float b){
        return hypotf(a, b);
    }
//erf and erfc
    static inline double __CBAS__erf(double a){
        return erf(a);
    }
    static inline float __CBAS__erff(float a){
        return erff(a);
    }
    static inline double __CBAS__erfc(double a){
        return erfc(a);
    }
    static inline float __CBAS__erfcf(float a){
        return erfcf(a);
    }
//gamma fns
    static inline double __CBAS__tgamma(double a){
        return tgamma(a);
    }
    static inline float __CBAS__tgammaf(float a){
        return tgammaf(a);
    }
    static inline double __CBAS__lgamma(double a){
        return lgamma(a);
    }
    static inline float __CBAS__lgammaf(float a){
        return lgammaf(a);
    }
//ceil floor
    static inline double __CBAS__ceil(double a){
        return ceil(a);
    }
    static inline float __CBAS__ceilf(float a){
        return ceilf(a);
    }
    static inline double __CBAS__floor(double a){
        return floor(a);
    }
    static inline float __CBAS__floorf(float a){
        return floorf(a);
    }    
    static inline double __CBAS__trunc(double a){
        return trunc(a);
    }
    static inline float __CBAS__truncf(float a){
        return truncf(a);
    }
    static inline double __CBAS__round(double a){
        return round(a);
    }
    static inline float __CBAS__roundf(float a){
        return roundf(a);
    }
//fmod
    static inline double __CBAS__fmod(double a, double b){
        return fmod(a,b);
    }
    static inline float __CBAS__fmodf(float a, float b){
        return fmodf(a,b);
    }
//nearbyint
    static inline double __CBAS__nearbyint(double a){
        return nearbyint(a);
    }
    static inline float __CBAS__nearbyintf(float a){
        return nearbyintf(a);
    }
//remainder
    static inline double __CBAS__remainder(double a, double b){
        return remainder(a,b);
    }
    static inline float __CBAS__remainderf(float a, float b){
        return remainderf(a,b);
    }    
    static inline double __CBAS__remquo(double a, double b, i32* q){
        int p = *q;
        double retval = remquo(a,b,&p);
        *q = p;
        return retval;
    }
    static inline float __CBAS__remquof(float a, float b, i32* q){
        int p = *q;
        float retval = remquof(a,b,&p);
        *q = p;
        return retval;
    }


//MULTITHREADING LIBRARY
#ifndef __APPLE__


static inline unsigned char* __CBAS__thread_new(){
    lsthread* p = malloc(sizeof(lsthread));
    init_lsthread(p);
    return (unsigned char*)p;
}
static inline void __CBAS__thread_delete(unsigned char* tr){
    lsthread* p = (lsthread*)tr;
    destroy_lsthread(p);
    free(p);
    return;
}

static inline void __CBAS__thread_assign_fn(unsigned char* tr, unsigned char* funk){
    lsthread* p = (lsthread*)tr;
    void* fnk = funk;
    p->execute = fnk;
}

static inline void __CBAS__thread_assign_arg(unsigned char* tr, unsigned char* arg){
    lsthread* p = (lsthread*)tr;
    p->argument = arg;
}

static inline void __CBAS__thread_start(unsigned char* tr){
    lsthread* p = (lsthread*)tr;
    start_lsthread(p);
}
static inline void __CBAS__thread_kill(unsigned char* tr){
    lsthread* p = (lsthread*)tr;
    kill_lsthread(p);
}

static inline void __CBAS__thread_step(unsigned char* tr){
    lsthread* p = (lsthread*)tr;
    step(p);
}

static inline void __CBAS__thread_lock(unsigned char* tr){
    lsthread* p = (lsthread*)tr;
    lock(p);
}

static inline unsigned char* __CBAS__mutex_new(){
    pthread_mutex_t* m = malloc(sizeof(pthread_mutex_t));
    pthread_mutex_init(m, NULL);
    return (unsigned char*)m;
}

static inline void __CBAS__mutex_delete(unsigned char* mtx){
    pthread_mutex_t* m = (pthread_mutex_t*)mtx;
	pthread_mutex_destroy(m);
	free(m);
}

static inline void __CBAS__mutex_lock(unsigned char* mtx){
    pthread_mutex_t* m = (pthread_mutex_t*)mtx;
	pthread_mutex_lock(m);
}
static inline void __CBAS__mutex_unlock(unsigned char* mtx){
    pthread_mutex_t* m = (pthread_mutex_t*)mtx;
	pthread_mutex_unlock(m);
}
#else
static inline unsigned char* __CBAS__thread_new(){
    return NULL;
}
static inline void __CBAS__thread_delete(unsigned char* tr){
    free(tr);
    return;
}

static inline void __CBAS__thread_assign_fn(unsigned char* tr, unsigned char* funk){
    return;
}

static inline void __CBAS__thread_assign_arg(unsigned char* tr, unsigned char* arg){
    return;
}

static inline void __CBAS__thread_start(unsigned char* tr){
    return;
}
static inline void __CBAS__thread_kill(unsigned char* tr){
    return;
}

static inline void __CBAS__thread_step(unsigned char* tr){
    return;
}

static inline void __CBAS__thread_lock(unsigned char* tr){
    return;
}

static inline unsigned char* __CBAS__mutex_new(){
    return NULL;
}

static inline void __CBAS__mutex_delete(unsigned char* mtx){
	free(mtx);
}

static inline void __CBAS__mutex_lock(unsigned char* mtx){
    return;
}
static inline void __CBAS__mutex_unlock(unsigned char* mtx){
    return;
}

#endif\n";

fn predecl noexport fopen(char* fname, char* mode)->TGT_UMAX; //returns a handle...
fn predecl noexport fclose(TGT_UMAX p)->int;


fn predecl noexport get_stdout_handle()->TGT_UMAX;
fn predecl noexport get_stdin_handle()->TGT_UMAX;
fn predecl noexport get_stderr_handle()->TGT_UMAX;

//returns number of bytes read/written
fn predecl noexport fwrite(TGT_UMAX fhandle, char* buf, TGT_UMAX nbytes)->TGT_UMAX;
fn predecl noexport fread(TGT_UMAX fhandle, char* buf, TGT_UMAX nbytes)->TGT_UMAX;

//get unix time...
fn predecl pure noexport get_utime()->TGT_UMAX;

fn predecl noexport set_errno(int new_errno);
fn predecl noexport get_errno()->int;


//memcpy...
fn predecl pure noexport mcpy(char* dst, char* src, TGT_UMAX sz);
fn predecl pure noexport mmove(char* dst, char* src, TGT_UMAX sz);



fn predecl noexport println(char* s);

//this is needed to get proper compiler optimization...
fn predecl pure noexport malloc(TGT_UMAX amt)->char*;
fn predecl pure noexport free(char* p);
fn predecl pure noexport realloc(char* p, TGT_UMAX amt)->char*;
fn predecl noexport sys_exit(int a);
/*
    TODO: Fill out the full feature set of
    the C standard library...
    
    I need stuff for controlling the terminal and
    doing 
*/
//trig
fn predecl noexport sin(double a)->double;
fn predecl noexport cos(double a)->double;
fn predecl noexport tan(double a)->double;

fn predecl noexport sinf(f32 a)->f32;
fn predecl noexport cosf(f32 a)->f32;
fn predecl noexport tanf(f32 a)->f32;

//arcs...
fn predecl noexport asin(double a)->double;
fn predecl noexport acos(double a)->double;
fn predecl noexport atan(double a)->double;

fn predecl noexport asinf(f32 a)->f32;
fn predecl noexport acosf(f32 a)->f32;
fn predecl noexport atanf(f32 a)->f32;
//atan2
fn predecl noexport atan2(double a, double b)->double;
fn predecl noexport atan2f(f32 a, f32 b)->f32;

//hyperbolics...
fn predecl noexport sinh(double a)->double;
fn predecl noexport cosh(double a)->double;
fn predecl noexport tanh(double a)->double;
fn predecl noexport asinh(double a)->double;
fn predecl noexport acosh(double a)->double;
fn predecl noexport atanh(double a)->double;

fn predecl noexport sinhf(f32 a)->f32;
fn predecl noexport coshf(f32 a)->f32;
fn predecl noexport tanhf(f32 a)->f32;
fn predecl noexport asinhf(f32 a)->f32;
fn predecl noexport acoshf(f32 a)->f32;
fn predecl noexport atanhf(f32 a)->f32;
//exponentiation...
fn predecl noexport exp(double a)->double;
fn predecl noexport expf(f32 a)->f32;
//frexp
fn predecl noexport frexp(f64 a, i32* b)->f64;
fn predecl noexport frexpf(f32 a, i32* b)->f32;
//ldexp (Notice: Not pointers in the second argument...)
fn predecl noexport ldexp(f64 a, i32 b)->f64;
fn predecl noexport ldexpf(f32 a, i32 b)->f32;
//log
fn predecl noexport log(double a)->double;
fn predecl noexport logf(f32 a)->f32;
fn predecl noexport log10(double a)->double;
fn predecl noexport log10f(f32 a)->f32;
fn predecl noexport log2(double a)->double;
fn predecl noexport log2f(f32 a)->f32;
fn predecl noexport logb(double a)->double;
fn predecl noexport logbf(f32 a)->f32;
//modf
fn predecl noexport modf(f64 a, f64* b)->f64;
fn predecl noexport modff(f32 a, f32* b)->f32;
//exponentiation2...
fn predecl noexport exp2(double a)->double;
fn predecl noexport exp2f(f32 a)->f32;
fn predecl noexport expm1(double a)->double;
fn predecl noexport expm1f(f32 a)->f32;
//ilogb
fn predecl noexport ilogbf(f32 a)->int;
fn predecl noexport ilogb(f64 a)->int;

fn predecl noexport log1p(double a)->double;
fn predecl noexport log1pf(f32 a)->f32;
fn predecl noexport scalbnf(f32 a, i32 n)->f32;
fn predecl noexport scalbn(f64 a, i32 n)->f64;
//pow
fn predecl noexport pow(double a, double b)->double;
fn predecl noexport powf(f32 a, f32 b)->f32;
//roots
fn predecl noexport sqrt(double a)->double;
fn predecl noexport sqrtf(f32 a)->f32;
fn predecl noexport cbrt(double a)->double;
fn predecl noexport cbrtf(f32 a)->f32;

fn predecl noexport hypot(double a, double b)->double;
fn predecl noexport hypotf(f32 a, f32 b)->f32;

fn predecl noexport erf(double a)->double;
fn predecl noexport erff(f32 a)->f32;

fn predecl noexport erfc(double a)->double;
fn predecl noexport erfcf(f32 a)->f32;
fn predecl noexport tgamma(double a)->double;
fn predecl noexport tgammaf(f32 a)->f32;
fn predecl noexport lgamma(double a)->double;
fn predecl noexport lgammaf(f32 a)->f32;

fn predecl noexport ceil(double a)->double;
fn predecl noexport ceilf(f32 a)->f32;
fn predecl noexport floor(double a)->double;
fn predecl noexport floorf(f32 a)->f32;
fn predecl noexport trunc(double a)->double;
fn predecl noexport truncf(f32 a)->f32;
fn predecl noexport round(double a)->double;
fn predecl noexport roundf(f32 a)->f32;
//fmod
fn predecl noexport fmod(f64 a, f64 b)->f64;
fn predecl noexport fmodf(f32 a, f32 b)->f32;
//nearby int
fn predecl noexport nearbyint(double a)->double;
fn predecl noexport nearbyintf(f32 a)->f32;
//remainder
fn predecl noexport remainder(f64 a, f64 b)->f64;
fn predecl noexport remainderf(f32 a, f32 b)->f32;
fn predecl noexport remquo(f64 a, f64 b, i32* q)->f64;
fn predecl noexport remquof(f32 a, f32 b, i32* q)->f32;

/*


    MULTITHREADING
*/

//allocate a thread object...
fn predecl noexport thread_new()->byte*;
//assign the function that a thread uses.
fn predecl noexport thread_assign_fn(byte* tr, byte* funk);
fn predecl noexport thread_assign_arg(byte* tr, byte* arg);
fn predecl noexport thread_start(byte* tr);

fn predecl noexport thread_step(byte* tr);
fn predecl noexport thread_lock(byte* tr);
fn predecl noexport thread_kill(byte* tr);
fn predecl noexport thread_delete(byte* tr);


//mutex stuff
fn predecl noexport mutex_new()->byte*;
fn predecl noexport mutex_delete(byte* mtx);
fn predecl noexport mutex_lock(byte* mtx);
fn predecl noexport mutex_unlock(byte* mtx);




