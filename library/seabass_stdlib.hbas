

/*
    USER-MODE STANDARD LIBRARY FOR SEABASS- BASIC INTERFACE.
    
    Should provide the basic functionality...
    
    Make sure to include a bitXX.hbas file...
    
    such as bit64.hbas or bit32.hbas
*/

#guard SEABASS_STDLIB_GNUC

//The glories of a multi-line string literal!
data codegen string SEABASS_STDLIB_PREFIX "\n\n
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#ifndef __APPLE__

#include <pthread.h>
#include <stdlib.h>
typedef struct {
	pthread_mutex_t myMutex;
	pthread_barrier_t myBarrier;
	pthread_t myThread;
	int isThreadLive;
	int shouldKillThread;
	int state;
	void (*execute)(unsigned char*);
	unsigned char* argument;
} lsthread;
static inline void init_lsthread(lsthread* t);
static inline void start_lsthread(lsthread* t);
static inline void kill_lsthread(lsthread* t);
static inline void destroy_lsthread(lsthread* t);
static inline void lock(lsthread* t);
static inline void step(lsthread* t);
static void* lsthread_func(void* me_void);

//function declarations

static inline void init_lsthread(lsthread* t){
	//t->myMutex = (pthread_mutex_t)PTHREAD_MUTEX_INITIALIZER;
	pthread_mutex_init(&t->myMutex, NULL);
	pthread_barrier_init(&t->myBarrier, NULL, 2);
	t->isThreadLive = 0;
	t->shouldKillThread = 0;
	t->state = 0;
	t->execute = NULL;
	t->argument = NULL;
}
static inline void destroy_lsthread(lsthread* t){
	pthread_mutex_destroy(&t->myMutex);
	pthread_barrier_destroy(&t->myBarrier);
}
static inline void lock(lsthread* t){
	if(t->state == 1)return;//if already locked, nono
	if(!t->isThreadLive)return;
	pthread_barrier_wait(&t->myBarrier);
	if(pthread_mutex_lock(&t->myMutex))
		exit(1);
	t->state = 1;
}

static inline void step(lsthread* t){
	if(t->state == -1)return; //if already stepping, nono
	if(!t->isThreadLive)return;
	if(pthread_mutex_unlock(&(t->myMutex)))
		exit(1);
	pthread_barrier_wait(&t->myBarrier);
	t->state = -1;
}
static inline void kill_lsthread(lsthread* t){
	if(!t->isThreadLive)return;
	if(t->state != 1){
		lock(t);
	}
	t->shouldKillThread = 1;
	step(t);
	
	pthread_join(t->myThread,NULL);
	
	t->isThreadLive = 0;
	t->shouldKillThread = 0;
}
static void* lsthread_func(void* me_void){
	lsthread* me = (lsthread*) me_void;
	if (!me)pthread_exit(NULL);
	while (1) {
		pthread_barrier_wait(&me->myBarrier);
		pthread_mutex_lock(&me->myMutex);
		if (!(me->shouldKillThread) && me->execute)
			me->execute(me->argument);
		else if(me->shouldKillThread){
			pthread_mutex_unlock(&me->myMutex);
			pthread_exit(NULL);
		}

		pthread_mutex_unlock(&me->myMutex);
		pthread_barrier_wait(&me->myBarrier);
	}
	pthread_exit(NULL);
}
static inline void start_lsthread(lsthread* t){
	if(t->isThreadLive)return;
	t->isThreadLive = 1;
	t->shouldKillThread = 0;
	if(pthread_mutex_lock(&t->myMutex))
		exit(1);
	t->state = 1; //LOCKED
	pthread_create(
		&t->myThread,
		NULL,
		lsthread_func,
		(void*)t
	);
}

#endif




static inline size_t __CBAS__openfile(unsigned char* fname, unsigned char* mode){
    return (size_t)fopen((char*)fname, (char*)mode);
}

static inline int __CBAS__closefile(size_t p){
    return fclose((FILE*)p);
}

static inline size_t __CBAS__get_stdout_handle(){
    return (size_t)stdout;
}

static inline size_t __CBAS__get_stdin_handle(){
    return (size_t)stdin;
}

static inline size_t __CBAS__get_stderr_handle(){
    return (size_t)stderr;
}

static inline size_t __CBAS__write_bytes(size_t fhandle, unsigned char* buf, size_t nbytes){
    return fwrite(buf, 1, nbytes,(FILE*)fhandle);
}

static inline size_t __CBAS__read_bytes(size_t fhandle, unsigned char* buf, size_t nbytes){
    return fread(buf, 1, nbytes,(FILE*)fhandle);
}

static inline size_t __CBAS__get_utime(){
    return time(0);
}


static inline void __CBAS__set_errno(int new_errno){
    errno = new_errno;
}

static inline int __CBAS__get_errno(){
    return errno;
}

//this is included in case we are not able to optimize...

static inline void __CBAS__mcpy(unsigned char* dst, unsigned char* src, size_t sz){
    memcpy(dst, src, sz);
}
static inline void __CBAS__mmove(unsigned char* dst, unsigned char* src, size_t sz){
    memmove(dst, src, sz);
}

//these are provided for similar reasons...
static inline unsigned char* __CBAS__mem_alloc(size_t amt){
    return malloc(amt);
}

static inline void __CBAS__mem_free(unsigned char* p){
    free(p);
}

static inline unsigned char* __CBAS__mem_realloc(unsigned char* b, size_t amt){
    return realloc(b, amt);
}

static inline void __CBAS__println(char* s){
    puts(s);
}

static inline void __CBAS__sys_exit(int a){
    exit(a);
}


//MULTITHREADING LIBRARY
#ifndef __APPLE__


static inline unsigned char* __CBAS__thread_new(){
    lsthread* p = malloc(sizeof(lsthread));
    init_lsthread(p);
    return (unsigned char*)p;
}
static inline void __CBAS__thread_delete(unsigned char* tr){
    lsthread* p = (lsthread*)tr;
    destroy_lsthread(p);
    free(p);
    return;
}

static inline void __CBAS__thread_assign_fn(unsigned char* tr, unsigned char* funk){
    lsthread* p = (lsthread*)tr;
    void* fnk = funk;
    p->execute = fnk;
}

static inline void __CBAS__thread_assign_arg(unsigned char* tr, unsigned char* arg){
    lsthread* p = (lsthread*)tr;
    p->argument = arg;
}

static inline void __CBAS__thread_start(unsigned char* tr){
    lsthread* p = (lsthread*)tr;
    start_lsthread(p);
}
static inline void __CBAS__thread_kill(unsigned char* tr){
    lsthread* p = (lsthread*)tr;
    kill_lsthread(p);
}

static inline void __CBAS__thread_step(unsigned char* tr){
    lsthread* p = (lsthread*)tr;
    step(p);
}

static inline void __CBAS__thread_lock(unsigned char* tr){
    lsthread* p = (lsthread*)tr;
    lock(p);
}

static inline unsigned char* __CBAS__mutex_new(){
    pthread_mutex_t* m = malloc(sizeof(pthread_mutex_t));
    pthread_mutex_init(m, NULL);
    return (unsigned char*)m;
}

static inline void __CBAS__mutex_delete(unsigned char* mtx){
    pthread_mutex_t* m = (pthread_mutex_t*)mtx;
	pthread_mutex_destroy(m);
	free(m);
}

static inline void __CBAS__mutex_lock(unsigned char* mtx){
    pthread_mutex_t* m = (pthread_mutex_t*)mtx;
	pthread_mutex_lock(m);
}
static inline void __CBAS__mutex_unlock(unsigned char* mtx){
    pthread_mutex_t* m = (pthread_mutex_t*)mtx;
	pthread_mutex_unlock(m);
}
#else
static inline unsigned char* __CBAS__thread_new(){
    return NULL;
}
static inline void __CBAS__thread_delete(unsigned char* tr){
    free(tr);
    return;
}

static inline void __CBAS__thread_assign_fn(unsigned char* tr, unsigned char* funk){
    return;
}

static inline void __CBAS__thread_assign_arg(unsigned char* tr, unsigned char* arg){
    return;
}

static inline void __CBAS__thread_start(unsigned char* tr){
    return;
}
static inline void __CBAS__thread_kill(unsigned char* tr){
    return;
}

static inline void __CBAS__thread_step(unsigned char* tr){
    return;
}

static inline void __CBAS__thread_lock(unsigned char* tr){
    return;
}

static inline unsigned char* __CBAS__mutex_new(){
    return NULL;
}

static inline void __CBAS__mutex_delete(unsigned char* mtx){
	free(mtx);
}

static inline void __CBAS__mutex_lock(unsigned char* mtx){
    return;
}
static inline void __CBAS__mutex_unlock(unsigned char* mtx){
    return;
}

#endif";

fn predecl noexport openfile(char* fname, char* mode)->TGT_UMAX; //returns a handle...
fn predecl noexport closefile(TGT_UMAX p)->int;


fn predecl noexport get_stdout_handle()->TGT_UMAX;
fn predecl noexport get_stdin_handle()->TGT_UMAX;
fn predecl noexport get_stderr_handle()->TGT_UMAX;

//returns number of bytes read/written
fn predecl noexport write_bytes(TGT_UMAX fhandle, char* buf, TGT_UMAX nbytes)->TGT_UMAX;
fn predecl noexport read_bytes(TGT_UMAX fhandle, char* buf, TGT_UMAX nbytes)->TGT_UMAX;

//get unix time...
fn predecl pure noexport get_utime()->TGT_UMAX;

fn predecl noexport set_errno(int new_errno);
fn predecl noexport get_errno()->int;


//memcpy...
fn predecl pure noexport mcpy(char* dst, char* src, TGT_UMAX sz);
fn predecl pure noexport mmove(char* dst, char* src, TGT_UMAX sz);



fn predecl noexport println(char* s);

//this is needed to get proper compiler optimization...
fn predecl pure noexport mem_alloc(TGT_UMAX amt)->char*;
fn predecl pure noexport mem_free(char* p);
fn predecl pure noexport mem_realloc(char* p, TGT_UMAX amt)->char*;
fn predecl noexport sys_exit(int a);
/*
    TODO: Fill out the full feature set of
    the C standard library...
    
    I need stuff for controlling the terminal and
    doing 
*/
/*
    MULTITHREADING
*/

//allocate a thread object...
fn predecl noexport thread_new()->byte*;
//assign the function that a thread uses.
fn predecl noexport thread_assign_fn(byte* tr, byte* funk);
fn predecl noexport thread_assign_arg(byte* tr, byte* arg);
fn predecl noexport thread_start(byte* tr);

fn predecl noexport thread_step(byte* tr);
fn predecl noexport thread_lock(byte* tr);
fn predecl noexport thread_kill(byte* tr);
fn predecl noexport thread_delete(byte* tr);


//mutex stuff
fn predecl noexport mutex_new()->byte*;
fn predecl noexport mutex_delete(byte* mtx);
fn predecl noexport mutex_lock(byte* mtx);
fn predecl noexport mutex_unlock(byte* mtx);




