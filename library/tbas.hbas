
#guard templated_cbas_library_DMHSW

/*
    GENERIC ANYTHING FOR SEABASS
    
    Generic types? Generic functions? Generic control flow?
    Generic generics?
    
    Can you imagine what it would mean to template it? We can
    serve it!
    
    The goal with Tbas is to allow you to refer to templated code
    inside of a function seamlessly, with the template parameters in-place.
    
    
    SEMANTICS
    
    ? HOW ARE TYPE ALIASES HANDLED ?
    Whenever a template is recognized, and it is being fed a "type"
    parameter, we convert all primitive types in that sequence into their natural
    aliases (e.g. uptr to u64, int to i32, etcetera).
    
    This ensures for instance that when we go to look for a template paramater, we don't
    ever confuse vector[i32] as not being the same as vector[int], nor
    vector[vector[i32]] not the same as vector[vector[int]].
    
    ? HOW DOES TBAS HANDLE COMPATIBILITY WITH NESTED DSLS ?
    
    It shouldn't ever be an issue, however, if it ever is, we'll
    include the $ escape character to escape a token.
    
    ? WHAT DO TBAS TEMPLATES EXPAND INTO ?
    
    Code in the prefix and body. Each of these
    two sections can be written to by a Tbas template.
    
    So every time that you have a worksheet written for
    Tbas, it needs to consist of two bracketed sections...
    
    [][]
    
    for the prefix and body expansions.
    
    Normally, for most things, I imagine that the prefix
    is not necessary to preserve. However, we might want to
    keep it around...
    
    TEMPLATE SYNTAX
    
    mktemplate type myType[type T, typename T2, ident I, Q][
        //prefix code....
    ]
    
    //usage...
    myType[int[3], int*, int, [int]]
    
    you can also use it for functions...
    mktemplate fn myfn[type T, typename T2, ident I, Q][
        //prefix code....
    ]
    
    and you can omit "type" or "fn" and instead just write arbitrary code...
    mktemplate myCode[type T, typename T2, ident I, Q][
        //prefix code....
    ]
    
    and you can specify body code as well (only for code...)
    mktemplate myCode[type T, typename T2, ident I, Q][
        //prefix code....
    ][
        //body code...
    ]
    
    ?WHAT HAPPENS WHEN A TEMPLATE IS DEFINED?
    * We check to see if a template by the same name exists- if it does,
        that's an error.
    * We create a worksheet for us to use internally, with a peculiarly mangled
      name. This worksheet is used to perform templating.
    
    
    ?WHAT HAPPENS WHEN A TEMPLATE IS INSTANTIATED?
    
    * Parse the parameter list and validate its correctness.
    * Check the list of instantiations to see if the instance has already
        been generated. If it has, we use it. Otherwise, we press onward...
    * A unique name is generated according to the template parameters.
    * we fill out the worksheet
*/

#include "cgtoken_manip_tools.hbas"

codegen u64 CG_TBAS_MAX_TEMPLATE_PARAMS = 64;


//an instance of a template
class cg_tbas_template_instance noexport
    //what were the parameters? This is an array of cgstrlls
    cgstrll*[CG_TBAS_MAX_TEMPLATE_PARAMS] params
    cgstrll* prefix_once  //what gets written only once? (Usually the template expansion...)
                          //theoretically, we could choose not to save this...
    cgstrll* body //what gets put in the body? (Usually just a single identifier...)
    u64 nparams
end

//a templated "thingie"
class cg_tbas_template noexport
    cgstr name //exposed api name
    cgstr internal_name //name of the worksheet
    u64 nparams //how many parameters does it take?
    u64 template_type /*
        Is this thing a---
        0. Unspecified?
        1. Type?
        2. Function?
    */
    cg_tbas_template_instance* instances
    u64 ninstances
    u8[CG_TBAS_MAX_TEMPLATE_PARAMS] paramtypes /*
        Are the parameters...
        0. Types (arrays not allowed)
        1. Types (arrays allowed)
        2. Identifiers
        3. Functions
        4. Integers
        5. Arbitrary token sequences?
    */
end

class cg_tbas_unit noexport
    cgstrll* prefix
    cgstrll* body
end


codegen cg_tbas_template* cg_tbas_templates = 0;
codegen u64 cg_tbas_ntemplates = 0;
codegen u64 cg_tbas_uuid_gen = 1; //start at 1

codegen cg_tbas_unit cg_tbas_cur_unit;

method codegen cg_tbas_unit.reset():
    this.prefix = 0;
    this.body = 0;
end

method codegen cg_tbas_template.ctor():
    this.name.s = 0;
    this.internal_name.s = 0;
    this.nparams = 0;
    this.instances = 0;
    this.ninstances = 0;
    //don't bother setting paramtypes...
end
//don't bother writing a dtor


method codegen cg_tbas_template_instance.ctor():
    u64 i
    for(i = 0, i < CG_TBAS_MAX_TEMPLATE_PARAMS, i++)
        this.params[i] = 0;
    end
    this.prefix_once = 0;
    this.body = 0;
    this.nparams = 0;
end

fn codegen cg_tbas_replace_type_aliases(cgstrll* in):
    /*in-place modify in....*/
    
    while(in != 0)
        if(in.d != CG_TOK_KEYWORD)
            goto nextiter
        end
        if(
            in.text streq "char" ||
            in.text streq "byte" ||
            in.text streq "ubyte" ||
            in.text streq "uchar"
        )
            __builtin_free(in.text);
            in.text = __builtin_strdup("u8");
        elif(
            in.text streq "sbyte" ||
            in.text streq "schar"
        )
            __builtin_free(in.text);
            in.text = __builtin_strdup("i8");
        elif(
            in.text streq "ushort"
        )
            __builtin_free(in.text);
            in.text = __builtin_strdup("u16");
        elif(
            in.text streq "short" ||
            in.text streq "sshort"
        )
            __builtin_free(in.text);
            in.text = __builtin_strdup("i16");
        elif(
            in.text streq "uint" ||
            in.text streq "ulong"
        )
            __builtin_free(in.text);
            in.text = __builtin_strdup("u32");
        elif(
            in.text streq "int" ||
            in.text streq "sint" ||
            in.text streq "long" ||
            in.text streq "slong"
        )
            __builtin_free(in.text);
            in.text = __builtin_strdup("i32");
        elif(
            in.text streq "ullong" ||
            in.text streq "uqword" ||
            in.text streq "qword" ||
            in.text streq "uptr"  //NOTE: PLATFORM DEPENDENT
        )
            __builtin_free(in.text);
            in.text = __builtin_strdup("u64");
        elif(
            in.text streq "sllong" ||
            in.text streq "llong" ||
            in.text streq "sqword" 
        )
            __builtin_free(in.text);
            in.text = __builtin_strdup("i64");
        elif(
            in.text streq "float" 
        )
            __builtin_free(in.text);
            in.text = __builtin_strdup("f32");
        elif(
            in.text streq "double" 
        )
            __builtin_free(in.text);
            in.text = __builtin_strdup("f64");
        end
        :nextiter
        in = in.right;
    end
end

//how you add templates to Tbas...
fn codegen cg_tbas_mktemplate(cgstrll* in):
    //TODO: make a template...
end

//How you 
fn codegen cg_tbas_instantiate_template(cgstrll* in, u64 tid):
    //TODO: Instantiate template...
end


