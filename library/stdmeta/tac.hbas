
//Three Address Codes for Seabass
#guard codegen_three_address_code_library_DMHSW
#include <stdmeta/reflect.hbas>

codegen int CG_TAC_NOP = 0;
codegen int CG_TAC_EXPR = 1;
codegen int CG_TAC_GOTO = 2;
codegen int CG_TAC_GOTOIF = 3;
codegen int CG_TAC_SCOPE = 4;
codegen int CG_TAC_RETURN = 5;
codegen int CG_TAC_TAIL = 6; //Explicit tail call
codegen int CG_TAC_SWITCH = 7; //Switch stmt
codegen int CG_TAC_LABEL = 8; //Label.


class cg_tac_expr
    noexport
    cgtype t
    i64[CG_MAX_FARGS] operands
    
    cgsymdecl* ref_gsym //function template for callfnptr, or function to call for EXPR_METHOD/EXPR_FCALL
                        //for getglobalptr and EXPR_GSYM this is used for retrieving global symbols.
                        //EXPR_GSYM is obviously converted into getglobalptr....
                        
    i64 dst             //destination variable uuid
    i64 ival            //for integer constants...
    f64 dval            //for double constants...
    char* stringval     //for string constants...
    
    short kind          //CG_EXPR_ type.... some kinds will not appear such as EXPR_MEMBER
                        //because we will always convert it to a sequence which uses
                        //EXPR_MEMBERPTR
end

class cg_tac_insn
    noexport
    byte* scope
    cg_tac_expr expr
    byte kind // CG_TAC_ ...
    cgsymdecl* ref_symbol //for tail
    cg_tac_insn** goto_targs //goto targets... need multiple for SWITCH.
                            //for goto we pun this into cg_tac_insn* (not double ptr)
    u64 n_goto_targs
end

method codegen cg_tac_insn.ctor:
    this.scope = 0;
    this.kind = 0;
    this.expr.ref_gsym = 0;
    this.expr.kind = -1;
    this.goto_targs = 0;
    this.n_goto_targs = 0;
end




class cg_tac_symbol
    noexport
    i64 id //negative if it's a function argument...
    cgtype t //type of the symbol
    char* srcname //name of the original variable this came from.
end

class cg_tac_scope
    noexport
    cg_tac_insn* insns
    cg_tac_symbol* syms
    u64 n_insns
    u64 n_syms
    byte isFunctionBody //is this scope a function body?
    byte isInline //is this an inline function?
end

method codegen cg_tac_scope.ctor:
    this.insns = 0;
    this.n_insns =0;
    this.syms = 0;
    this.n_syms = 0;
    this.isFunctionBody = 0;
    this.isInline = 0;
end
method codegen cg_tac_scope.dtor:
    u64 i
    for(i = 0, i < this.n_insns, i++)
        cg_tac_scope* p = (cg_tac_scope*)this.insns[i].scope;
        if(p != 0)
            p.dtor();
            __builtin_free((u8*)p);
        end
        if(this.insns[i].goto_targs != 0 && this.insns[i].kind == CG_TAC_SWITCH)
            __builtin_free((u8*)this.insns[i].goto_targs);
        end
    end
    if(this.insns != 0)
        __builtin_free((u8*)this.insns);
    end
    if(this.syms != 0)
        __builtin_free((u8*)this.syms);
    end
end

codegen uqword cg_tac_symgen = 1;
fn codegen cg_tac_gen_symname->u64:
    return cg_tac_symgen++
end

method codegen cg_tac_scope.push_farg(cgtype p,char* n)->i64:
    //TODO
    this.syms = (cg_tac_symbol*)__builtin_realloc((u8*)this.syms, sizeof(cg_tac_symbol) * ++this.n_syms);
    u64 w = this.n_syms-1;
    
    this.syms[w].id = cg_tac_gen_symname * -1;
    this.syms[w].t := p;
    this.syms[w].srcname = n;
    return this.syms[w].id;
end

method codegen cg_tac_scope.push_var(cgtype p, char* n)->i64:
    //TODO
    this.syms = (cg_tac_symbol*)__builtin_realloc((u8*)this.syms, sizeof(cg_tac_symbol) * ++this.n_syms);
    u64 w = this.n_syms-1;
    
    this.syms[w].id = cg_tac_gen_symname;
    this.syms[w].t := p;
    this.syms[w].srcname = n;
    return this.syms[w].id;
end

codegen cgscope*[0x10000] cg_tac_cgscopestack;
codegen cg_tac_scope*[0x10000] cg_tac_scopestack;
codegen uqword cg_tac_cgscopestack_depth = 0;
codegen uqword cg_tac_scopestack_depth = 0;

fn codegen cg_tac_cgscopestack_push(cgscope* s):
    cg_tac_cgscopestack[cg_tac_cgscopestack_depth++] = s;
end

fn codegen cg_tac_cgscopestack_pop():
    cg_tac_cgscopestack_depth--;
end


fn codegen cg_tac_scopestack_push(cg_tac_scope* s):
    cg_tac_scopestack[cg_tac_scopestack_depth++] = s;
end

fn codegen cg_tac_scopestack_pop():
    cg_tac_scopestack_depth--;
end

fn codegen cg_tac_cgscopestack_gettop()->cgscope:
    return cg_tac_cgscopestack[cg_tac_cgscopestack_depth-1];
end
fn codegen cg_tac_scopestack_gettop()->cg_tac_scope:
    return cg_tac_scopestack[cg_tac_scopestack_depth-1];
end



fn codegen cg_tac_convert_expr(
    cg_tac_scope cur_scope, //The scope to add this expression instruction to
    cgexpr_node srcnode,    //the source expression node.
    cgstmt srcstmt,         //the source statement of the expressio node.
    cgscope srcscope,       //the scope from which this stmt came
    cgsymdecl srcfn         //the function the scope is in.
):
    //TODO... complicated! This creates tac_insns
end

fn codegen cg_tac_convert_stmt(cg_tac_scope cur_scope, cgstmt srcstmt, cgscope srcscope,cgsymdecl srcfn):
    //TODO... convert this statement...
end

fn codegen cg_tac_convert_scope(cg_tac_insn parent_insn, cgscope srcscope, cgsymdecl srcfn):
    parent_insn.scope = __builtin_malloc(sizeof(cg_tac_scope));
    cg_tac_scope* s = (cg_tac_scope*)parent_insn.scope;
    //TODO... convert srcscope...
end


//Main entry point...
fn codegen cg_tac_convert_function(cgsymdecl* s)->cg_tac_scope:
    cg_tac_scopestack_depth = 0; //reset the scopestack...
    cg_tac_scope* rval;
    cgscope* fbody = (cgscope*)s.fbody;
    rval = (cg_tac_scope*)__builtin_malloc(sizeof(cg_tac_scope));
    rval.ctor();
    rval.isFunctionBody = 1;
    //TODO- convert function arguments...
    i64 i
    cg_tac_scopestack_push(rval);
    cg_tac_cgscopestack_push(fbody);
    for(i = 0, i < s.nargs, i++)
        rval.push_farg(s.fargs[i],s.fargs[i].membername);
    end
    //TODO: Convert function body..
    //safety- catch fbody is null (Should never happen....)
    if(fbody == 0)
        return rval
    end
    
    for(i = 0, i < fbody.nsyms, i++)
        rval.push_var(fbody.syms[i].t, fbody.syms[i].name);
    end
    for(i = 0, i < fbody.nstmts, i++)
        cg_tac_convert_stmt(rval, ((cgstmt*)fbody.stmts)[i], fbody,  s);
    end
    cg_tac_cgscopestack_pop();
    cg_tac_scopestack_pop();
    
    return rval;
end


