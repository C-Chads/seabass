
//Three Address Codes for Seabass
#guard codegen_three_address_code_library_DMHSW
#include <stdmeta/reflect.hbas>
//#include <stdmeta/tok_manip.hbas>


codegen int CG_TAC_NOP = 0;
codegen int CG_TAC_EXPR = 1;
codegen int CG_TAC_GOTO = 2;
codegen int CG_TAC_GOTOIF = 3;
codegen int CG_TAC_SCOPE = 4;
codegen int CG_TAC_RETURN = 5;
codegen int CG_TAC_TAIL = 6; //Explicit tail call
codegen int CG_TAC_SWITCH = 7; //Switch stmt
codegen int CG_TAC_LABEL = 8; //Label.
codegen int CG_TAC_ASM = 9; //code

codegen int CG_EXPR_LOAD = 500; //used for pointer load, same as [0]

codegen uqword cg_tac_symgen = 1; //symbol generation starts at 1....
fn codegen cg_tac_gen_symname->u64:
    return cg_tac_symgen++
end


class cg_tac_expr
    noexport
    cgtype t
    i64[CG_MAX_FARGS] operands
    u64 n_operands
    cgsymdecl* ref_gsym //function template for callfnptr, or function to call for EXPR_METHOD/EXPR_FCALL
                        //for getglobalptr and EXPR_GSYM this is used for retrieving global symbols.
                        //EXPR_GSYM is obviously converted into getglobalptr....
                        
    i64 dst             //destination variable uuid
    i64 ival            //for integer constants...
    f64 dval            //for double constants...
    char* stringval     //for string constants...
    
    short kind          //CG_EXPR_ type.... some kinds will not appear such as EXPR_MEMBER
                        //because we will always convert it to a sequence which uses
                        //EXPR_MEMBERPTR
end

class cg_tac_insn
    noexport
    byte* scope
    cg_tac_expr expr
    byte kind // CG_TAC_ ...
    cgsymdecl* ref_symbol //for tail
    char** goto_targs //goto targets... need multiple for SWITCH.
                      //for goto/label we pun this into char* (not double ptr)
    u64 n_goto_targs
end

method codegen cg_tac_insn.ctor:
    this.scope = 0;
    this.kind = 0;
    this.expr.ref_gsym = 0;
    this.expr.stringval = 0;
    this.expr.n_operands = 0;
    this.expr.kind = -1;
    this.goto_targs = 0;
    this.n_goto_targs = 0;
end




class cg_tac_symbol
    noexport
    i64 id //negative if it's a function argument...
    cgtype t //type of the symbol
    char* srcname //name of the original variable this came from.
end

class cg_tac_scope
    noexport
    cg_tac_insn* insns
    cg_tac_symbol* syms
    u64 n_insns
    u64 n_syms
    byte isFunctionBody //is this scope a function body?
    byte isInline //is this an inline function?
    byte detectedInliningLoop //Is an inlining loop detected?
end

method codegen cg_tac_scope.ctor:
    this.insns = 0;
    this.n_insns =0;
    this.syms = 0;
    this.n_syms = 0;
    this.isFunctionBody = 0;
    this.isInline = 0;
    this.detectedInliningLoop = 0;
end
method codegen cg_tac_scope.dtor:
    u64 i
    for(i = 0, i < this.n_insns, i++)
        cg_tac_scope* p = (cg_tac_scope*)this.insns[i].scope;
        if(p != 0)
            p.dtor();
            __builtin_free((u8*)p);
        end
        if(this.insns[i].goto_targs != 0 && this.insns[i].kind == CG_TAC_SWITCH)
            __builtin_free((u8*)this.insns[i].goto_targs);
        end
    end
    if(this.insns != 0)
        __builtin_free((u8*)this.insns);
    end
    if(this.syms != 0)
        __builtin_free((u8*)this.syms);
    end
end

method codegen cg_tac_scope:copy(cg_tac_scope** dest, byte is_inlining):
    //TODO
end



method codegen cg_tac_scope.push_farg(cgtype p,char* n)->i64:
    //TODO
    this.syms = (cg_tac_symbol*)__builtin_realloc((u8*)this.syms, sizeof(cg_tac_symbol) * ++this.n_syms);
    u64 w = this.n_syms-1;
    
    this.syms[w].id = cg_tac_gen_symname() * -1;
    this.syms[w].t := p;
    this.syms[w].srcname = n;
    return this.syms[w].id;
end

method codegen cg_tac_scope.push_var(cgtype p, char* n)->i64:
    //TODO
    this.syms = (cg_tac_symbol*)__builtin_realloc((u8*)this.syms, sizeof(cg_tac_symbol) * ++this.n_syms);
    u64 w = this.n_syms-1;
    
    this.syms[w].id = cg_tac_gen_symname();
    this.syms[w].t := p;
    this.syms[w].srcname = n;
    return this.syms[w].id;
end

method codegen cg_tac_scope.push_insn(cg_tac_insn insn):

    this.insns = (cg_tac_insn*)__builtin_realloc((u8*)this.insns, sizeof(cg_tac_insn) * ++this.n_insns);
    u64 w = this.n_insns-1;
    this.insns[w] := insn;
    //DONE
end

codegen cgscope*[0x10000] cg_tac_cgscopestack;
codegen cg_tac_scope*[0x10000] cg_tac_scopestack;
codegen uqword cg_tac_cgscopestack_depth = 0;
codegen uqword cg_tac_scopestack_depth = 0;

fn codegen cg_tac_cgscopestack_push(cgscope* s):
    cg_tac_cgscopestack[cg_tac_cgscopestack_depth++] = s;
end

fn codegen cg_tac_cgscopestack_pop():
    cg_tac_cgscopestack_depth--;
end


fn codegen cg_tac_scopestack_push(cg_tac_scope* s):
    cg_tac_scopestack[cg_tac_scopestack_depth++] = s;
end

fn codegen cg_tac_scopestack_pop():
    cg_tac_scopestack_depth--;
end

fn codegen cg_tac_cgscopestack_gettop()->cgscope:
    return cg_tac_cgscopestack[cg_tac_cgscopestack_depth-1];
end
fn codegen cg_tac_scopestack_gettop()->cg_tac_scope:
    return cg_tac_scopestack[cg_tac_scopestack_depth-1];
end

fn codegen cg_tac_insert_pointer_read(
    i64 readfrom, //variable to read from...
    cgtype* t     //the type of the variable to be read from.
):
    //TODO: generate an CG_EXPR_LOAD
    i64 v
    //cgtype tdecayed
    cg_tac_insn loadinsn
    loadinsn.kind = CG_TAC_EXPR;
    loadinsn.expr.t := t;
    loadinsn.expr.t.is_lvalue = 0;
    loadinsn.expr.kind = CG_EXPR_LOAD; // pointer decay...
    v = cg_tac_scopestack_gettop().push_var(loadinsn.expr.t, (char*)0);
    loadinsn.expr.dst = v;
    loadinsn.expr.operands[0] = readfrom;
    loadinsn.expr.n_operands = 1;
    cg_tac_scopestack_gettop().push_insn(loadinsn);
    
    
end

fn codegen cg_tac_convert_expr(
    cg_tac_scope cur_scope, //The scope to add this expression instruction to
    cgexpr_node srcnode,    //the source expression node.
    cgstmt srcstmt,         //the source statement of the expressio node.
    cgscope srcscope,       //the scope from which this stmt came
    cgsymdecl srcfn         //the function the scope is in.
):
    //TODO... complicated! This creates tac_insns
    if(srcnode.kind == CG_EXPR_FCALL || srcnode.kind == CG_EXPR_METHOD)
    elif(srcnode.kind == CG_EXPR_SIZEOF)
    elif(srcnode.kind == CG_EXPR_INTLIT || srcnode.kind == CG_EXPR_CONSTEXPR_INT)
    elif(srcnode.kind == CG_EXPR_FLOATLIT || srcnode.kind == CG_EXPR_CONSTEXPR_FLOAT)
    elif(srcnode.kind == CG_EXPR_LSYM)
    elif(srcnode.kind == CG_EXPR_GSYM)
        //This will yield a POINTER to the gsym....
        //luckily, we CAST every SYM usage, so this
        //will be TRANSFORMED into a value
        //by the cast for a read, but for a write,
        //we must detect it inside of ASSIGN/INCR/DECR
    elif(srcnode.kind == CG_EXPR_POST_INCR)
        //REMEMBER the LSYM detail!!! (GSYM/INDEX require conversion to MOVEs)
    elif(srcnode.kind == CG_EXPR_POST_DECR)
        //REMEMBER the LSYM detail!!!
    elif(srcnode.kind == CG_EXPR_INDEX)
        //Indexing a pointer yields an LVALUE, which is ASSIGNABLE.
        //We must remember this whenever we do an ASSIGNMENT or a CAST.
        //ASSIGNMENT must convert the assignment into an EXPR_MOVE
        //CAST must perform a READ from the pointer....
    elif(srcnode.kind == CG_EXPR_MEMBER)
    elif(srcnode.kind == CG_EXPR_CAST)
        //if it was an INDEX or CAST we must read the pointer into a value...
    elif(srcnode.kind == CG_EXPR_NEG)
    elif(srcnode.kind == CG_EXPR_COMPL)
    elif(srcnode.kind == CG_EXPR_PRE_INCR)
        //NOTE: we must detect if this is LSYM to see if it's valid to literally just increment...
    elif(srcnode.kind == CG_EXPR_PRE_DECR)
        //NOTE: we must detect if this is LSYM to see if it's valid to literally just decrement...
    elif(srcnode.kind == CG_EXPR_MUL)
    elif(srcnode.kind == CG_EXPR_DIV)
    elif(srcnode.kind == CG_EXPR_MOD)
    elif(srcnode.kind == CG_EXPR_ADD)
    elif(srcnode.kind == CG_EXPR_SUB)
    elif(srcnode.kind == CG_EXPR_BITOR)
    elif(srcnode.kind == CG_EXPR_BITAND)
    elif(srcnode.kind == CG_EXPR_LSH)
    elif(srcnode.kind == CG_EXPR_RSH)
    elif(srcnode.kind == CG_EXPR_LOGOR)
    elif(srcnode.kind == CG_EXPR_LOGAND)
    elif(srcnode.kind == CG_EXPR_LT)
    elif(srcnode.kind == CG_EXPR_GT)
    elif(srcnode.kind == CG_EXPR_LTE)
    elif(srcnode.kind == CG_EXPR_GTE)
    elif(srcnode.kind == CG_EXPR_EQ)
    elif(srcnode.kind == CG_EXPR_NEQ)
    elif(srcnode.kind == CG_EXPR_ASSIGN)
    elif(srcnode.kind == CG_EXPR_MOVE)
    elif(srcnode.kind == CG_EXPR_STREQ)
    elif(srcnode.kind == CG_EXPR_STRNEQ)
    elif(srcnode.kind == CG_EXPR_MEMBERPTR)
    elif(srcnode.kind == CG_EXPR_GETFNPTR)
    elif(srcnode.kind == CG_EXPR_CALLFNPTR)
    elif(srcnode.kind == CG_EXPR_GETGLOBALPTR)
    end
end

fn codegen cg_tac_convert_scope(
    cg_tac_insn parent_insn, 
    cgscope srcscope, 
    cgsymdecl srcfn
);

fn codegen cg_tac_convert_stmt(
    cg_tac_scope cur_scope, 
    cgstmt srcstmt, 
    cgscope srcscope,
    cgsymdecl srcfn
):
    //TODO... convert this statement...
    
end

fn codegen cg_tac_convert_scope(
    cg_tac_insn parent_insn, 
    cgscope srcscope, 
    cgsymdecl srcfn
):
    parent_insn.scope = __builtin_malloc(sizeof(cg_tac_scope));
    cg_tac_scope* s = (cg_tac_scope*)parent_insn.scope;
    //TODO... convert srcscope...
end


//Main entry point...
fn codegen cg_tac_convert_function(cgsymdecl* s)->cg_tac_scope:
    cg_tac_scopestack_depth = 0; //reset the scopestack...
    cg_tac_scope* rval;
    cgscope* fbody = (cgscope*)s.fbody;
    rval = (cg_tac_scope*)__builtin_malloc(sizeof(cg_tac_scope));
    rval.ctor();
    rval.isFunctionBody = 1;
    //TODO- convert function arguments...
    i64 i
    cg_tac_scopestack_push(rval);
    cg_tac_cgscopestack_push(fbody);
    for(i = 0, i < s.nargs, i++)
        rval.push_farg(s.fargs[i],s.fargs[i].membername);
    end
    //TODO: Convert function body..
    //safety- catch fbody is null (Should never happen....)
    if(fbody == 0)
        return rval
    end
    
    for(i = 0, i < fbody.nsyms, i++)
        rval.push_var(fbody.syms[i].t, fbody.syms[i].name);
    end
    for(i = 0, i < fbody.nstmts, i++)
        cg_tac_convert_stmt(rval, ((cgstmt*)fbody.stmts)[i], fbody,  s);
    end
    cg_tac_cgscopestack_pop();
    cg_tac_scopestack_pop();
    
    return rval;
end


