
DOCUMENTATION- FOR MY FUTURE SELF (Not sufficient for other programmers)

~~~~~~~~~~~~~~~~~~

cg_string.hbas defines the cgstr class, which holds the
compiletime string library.

cgstr is the name of the compiletime string class.
~~~~~~~~~~~~~~~
cgast.hbas defines the reflection types- the structs from
within the `cbas` program in C which are retrieved from
the builtin functions.

cgstrll is the name of the compiletime token class, which is the
most frequently used reflected type. It is a linked list node, with
`right` being the pointer to the next token.
~~~~~~~~~~~~~~~~~
cgbuilder.hbas defines the builder ("@bldr") and builder-n ("@bldrn"),
which allow one or multiple arguments, respectively.

there is a wrapper for each called "@mkbldr" and "mkbldrn" which are

used to enable access to the compiletime builder helper database.

Their syntaxes are:

@mkbldr [
    builder_name
    //cbas code
    code();
    return cg_qtok(";");
]


/*NOTE: n_args is an __integer literal__*/
@mkbldrn builder_name n_args  [
    code();
    return cg_qtok(";");
]

>>>         the convention of using brackets to encapsulate
>>>         arguments to a builder or parsehook is well-baked into the
>>>         library.




Numerous helper macros are also defined, which are used
for writing builders. Notably, they assume the existence of,
or create, commonly used variables (retval, rwalk, inlist_dupe, etc).

These variables are usually token pointers (cgstrll*) but sometimes
they are things like `dummy`.

`retval` is usually a `cgstrll*` representing the output. It can also be a `cgstrll`,
    if retval is being used as a `dummy` and therefore will not be returned. Instead,
    `retval.right` is returned.
`rwalk` is usually a pointer to the very last element in `retval`'s right-hand children.
`dummy` is usually a `cgstrll`. It can be used both on inputs (for processing argument lists)
    or on outputs (for holding the returned token list). If the latter, then the return value
    is usually supposed to be `dummy.right`.
~~~~~~~~~~~~~~~
cgrdparse.hbas defines the compiletime recursive descent parser generator.

This is by far the most complicated tool in the entire library written so far.

It is essentially a template with scoped macros. Certain operations and tests
such as 'eat', 'match' or 'this.tok' are made into macros.

it creates a recursive descent parser given a short implementation in code.

An example parser is present in `cgtoken_manip_tools.hbas` which 
implements this syntax extension:

@pprint [
        /                   "Hello!"
        /                   "LOOK HERE PROGRAMMER!!!"
        /                   "These"
        /                   "are"
        /                   "Separately"
        /                   "printed!"
        /itoa               (3*9+5+1)
        /                   "Did you like that?"
]
~~~~~~~~~~~~~~~~~~~~~~~~~
cgwksht.hbas contains the standard code templating tool for cbas.

The syntax for creating a worksheet looks like this (relevant sections marked with comments)

@wksht qfor [
    //1
    [
        if(1)
            u64 varname
            for(begin, test, iter)
                body
            end
        end
    ]
    //2
    [
        varname
        begin test iter body
    ]
    //3
    [
        return result;
    ]
]
The first section is the code template.
the second section is the list of arguments to the template.
the third section can be omitted.

this creates a `bldrn` using `mkbldrn` which takes in 5 arguments (in order) and




