
I WANT TO WRITE CBASPLUSPLUS.

A C++-like language for Cbas with the following features:

* Exceptions

* Templates

* Owning Pointers & References

* Enums

* A match statement which takes in an enum and requires all cases be handled

* Some scheme for doing guaranteed memory-safe and data-race-safe programming, ala Rust

    BUT BETTER THAN THE BORROW CHECKER...

* Multithreading (Using stuff from the seabass stdlib)

* Parsehooks (Just like Seabass)

* Automatically written Ctors/Dtors

HOW DO OWNING POINTERS / REFERENCES IN CBAS++ WORK?

After some thought, the pointer system from CBAS
can be used as "references" and a special owningptr
type can be used for owning pointers.

so a reference will be declared like this:

myStruct* myReference

and an owning pointer like this:

owned myStruct* myVariable

The only difference between them is that the CBAS++
compiler will automatically generate a destructor
call and a free() for the latter.

AUTOMATIC CTOR/DTOR AUTHORING

For most data types, CBAS++ should automatically create ctor and dtor.

However, for some special structs, this might not work. For instance, a file handle
might need to be opened or closed. For these special structs, a special keyword (perhaps "complicated")
should be reserved for indicating to CBAS++ that it cannot automatically write a ctor and dtor
and that manual implementation is required.

If a struct contains no owning pointers, then there is nothing that a `ctor` or `dtor` would do, so
they are either generated as empty, or not generated at all.

WHAT CAUSES DATA RACES?

Sharing mutable data structures without locks. So if you share a mutable data structure between threads, all accesses (even reads) must be locked.

I should come up with a scheme for explicitly defining state as shared between threads or not.


THE AGENT MODEL

Each thread of execution in CBAS++ will be modeled as a (static, global) set of objects which
contain private state as well as immutable references, and mutable global references.

Mutable global references will always involve inserting locks before access. 

All of these agent members will be namespaced to the agent's functions, which prevent any
external functions from violating the consistency of the agent.



