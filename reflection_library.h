"\n"
"\n"
"#guard CompileTimeASTManip_DMHSW\n"
"\n"
"#define CG_MAX_FARGS 64\n"
"\n"
"codegen u8* CG_TOK_SPACE       =0;\n"
"codegen u8* CG_TOK_NEWLINE     =1;\n"
"codegen u8* CG_TOK_STRING      =2;\n"
"codegen u8* CG_TOK_CHARLIT     =3;\n"
"codegen u8* CG_TOK_COMMENT     =4;\n"
"codegen u8* CG_TOK_MACRO       =5;\n"
"codegen u8* CG_TOK_INT_CONST   =6;\n"
"codegen u8* CG_TOK_FLOAT_CONST =7;\n"
"codegen u8* CG_TOK_IDENT    =8;\n"
"codegen u8* CG_TOK_OPERATOR =9;\n"
"codegen u8* CG_TOK_OCB    =10;\n"
"codegen u8* CG_TOK_CCB    =11;\n"
"codegen u8* CG_TOK_OPAREN =12;\n"
"codegen u8* CG_TOK_CPAREN =13;\n"
"codegen u8* CG_TOK_OBRACK =14;\n"
"codegen u8* CG_TOK_CBRACK =15;\n"
"codegen u8* CG_TOK_SEMIC =16;\n"
"codegen u8* CG_TOK_UNKNOWN =17;\n"
"codegen u8* CG_TOK_KEYWORD =18;\n"
"codegen u8* CG_TOK_ESC_NEWLINE =19;\n"
"codegen u8* CG_TOK_COMMA =20;\n"
"codegen u8* CG_TOK_MACRO_OP = 21;\n"
"codegen u8* CG_TOK_INCSYS = 22;\n"
"codegen u8* CG_TOK_INCLUDE = 23;\n"
"codegen u8* CG_TOK_DEFINE = 24;\n"
"codegen u8* CG_TOK_UNDEF = 25;\n"
"codegen u8* CG_TOK_GUARD = 26;\n"
"\n"
"codegen int CG_BASE_VOID=0;\n"
"codegen int CG_BASE_U8=1;\n"
"codegen int CG_BASE_I8=2;\n"
"codegen int CG_BASE_U16=3;\n"
"codegen int CG_BASE_I16=4;\n"
"codegen int CG_BASE_U32=5;\n"
"codegen int CG_BASE_I32=6;\n"
"codegen int CG_BASE_U64=7;\n"
"codegen int CG_BASE_I64=8;\n"
"codegen int CG_BASE_F32=9;\n"
"codegen int CG_BASE_F64=10;\n"
"codegen int CG_BASE_STRUCT=11;\n"
"codegen int CG_BASE_FUNCTION=12;\n"
"codegen int CG_NBASETYPES=13;\n"
"\n"
"codegen int\tCG_EXPR_BAD=0;\n"
"codegen int CG_EXPR_BUILTIN_CALL=1; \n"
"codegen int CG_EXPR_FCALL=2; \n"
"codegen int CG_EXPR_SIZEOF=3; \n"
"codegen int CG_EXPR_INTLIT=4; \n"
"codegen int CG_EXPR_FLOATLIT=5; \n"
"codegen int CG_EXPR_STRINGLIT=6;  \n"
"codegen int CG_EXPR_LSYM=7; \n"
"codegen int CG_EXPR_GSYM=8; \n"
"codegen int CG_EXPR_SYM=9; \n"
"codegen int CG_EXPR_POST_INCR=10;\n"
"codegen int CG_EXPR_POST_DECR=11; \n"
"codegen int CG_EXPR_INDEX=12; \n"
"codegen int CG_EXPR_MEMBER=13; \n"
"codegen int CG_EXPR_METHOD=14; \n"
"codegen int CG_EXPR_CAST=15; \n"
"codegen int CG_EXPR_NEG=16; \n"
"codegen int CG_EXPR_COMPL=17; \n"
"codegen int CG_EXPR_NOT=18; \n"
"codegen int CG_EXPR_PRE_INCR=19; \n"
"codegen int CG_EXPR_PRE_DECR=20; \n"
"codegen int CG_EXPR_MUL=21; \n"
"codegen int CG_EXPR_DIV=22; \n"
"codegen int CG_EXPR_MOD=23; \n"
"codegen int CG_EXPR_ADD=24; \n"
"codegen int CG_EXPR_SUB=25; \n"
"codegen int CG_EXPR_BITOR=26; \n"
"codegen int CG_EXPR_BITAND=27; \n"
"codegen int CG_EXPR_BITXOR=28; \n"
"codegen int CG_EXPR_LSH=29; \n"
"codegen int CG_EXPR_RSH=30; \n"
"codegen int CG_EXPR_LOGOR=31; \n"
"codegen int CG_EXPR_LOGAND=32; \n"
"codegen int CG_EXPR_LT=33; \n"
"codegen int CG_EXPR_GT=34; \n"
"codegen int CG_EXPR_LTE=35; \n"
"codegen int CG_EXPR_GTE=36; \n"
"codegen int CG_EXPR_EQ=37; \n"
"codegen int CG_EXPR_NEQ=38; \n"
"codegen int CG_EXPR_ASSIGN=39; \n"
"codegen int CG_EXPR_MOVE=40; \n"
"codegen int CG_EXPR_CONSTEXPR_FLOAT=41; \n"
"codegen int CG_EXPR_CONSTEXPR_INT=42; \n"
"codegen int CG_EXPR_STREQ=43; \n"
"codegen int CG_EXPR_STRNEQ=44; \n"
"codegen int CG_EXPR_MEMBERPTR=45; \n"
"codegen int CG_EXPR_GETFNPTR=46; \n"
"codegen int CG_EXPR_CALLFNPTR=47; \n"
"codegen int CG_EXPR_GETGLOBALPTR=48; \n"
"codegen int CG_NEXPR_TYPES=49;\n"
"\n"
"codegen int CG_STMT_BAD=0;\n"
"codegen int CG_STMT_NOP=1;\n"
"codegen int CG_STMT_EXPR=2;\n"
"codegen int CG_STMT_LABEL=3;\n"
"codegen int CG_STMT_GOTO=4;\n"
"codegen int CG_STMT_WHILE=5;\n"
"codegen int CG_STMT_FOR=6;\n"
"codegen int CG_STMT_IF=7;\n"
"codegen int CG_STMT_ELIF=8;\n"
"codegen int CG_STMT_ELSE=9;\n"
"codegen int CG_STMT_RETURN=10;\n"
"codegen int CG_STMT_TAIL=11;\n"
"codegen int CG_STMT_ASM=12;\n"
"codegen int CG_STMT_CONTINUE=13;\n"
"codegen int CG_STMT_BREAK=14;\n"
"codegen int CG_STMT_SWITCH=15;\n"
"codegen int CG_NSTMT_TYPES;\n"
"\n"
"\n"
"\n"
"/*\n"
"\tString library code for compiletime cbas code.\n"
"*/\n"
"\n"
"class cgstr\n"
"    noexport\n"
"\tchar* s\n"
"end\n"
"\n"
"fn codegen cgstrcpy(char* s, char* s1):\n"
"\twhile(1)\n"
"\t\ts[0] = s1[0];\n"
"\t\tif(s1[0] == 0) return; end\n"
"\t\ts++;s1++;\n"
"\tend\n"
"end\n"
"\n"
"fn codegen cgisdigit(char c)->u8:\n"
"\tif(c >= '0' && c <= '9') return 1; end\n"
"\treturn 0;\n"
"end\n"
"\n"
"fn codegen cgisalpha(char c)->u8:\n"
"\tif(c >= 'a' && c <= 'z') return 1; end\n"
"\tif(c >= 'A' && c <= 'Z') return 1; end\n"
"\treturn 0;\n"
"end\n"
"\n"
"method codegen pure cgstr:isempty()->u8:\n"
"\tif(this.s == cast(char*)0)\n"
"\t\treturn 1; \n"
"\tend\n"
"\tif(this.s[0] == 0)\n"
"\t\treturn 1;\n"
"\tend\n"
"\treturn 0;\n"
"end\n"
"\n"
"method codegen pure cgstr:isnull()->u8:\n"
"\tif(this.s == cast(char*)0)\n"
"\t\treturn 1; \n"
"\tend\n"
"\treturn 0;\n"
"end\n"
"\n"
"method codegen pure cgstr:len()->u64:\n"
"\tu64 i\n"
"\ti = 0;\n"
"\n"
"\t//necessary to prevent segfaults\n"
"\tif(this:isempty())\n"
"\t\treturn 0; \n"
"\tend\n"
"\n"
"\t//count characters\n"
"\tfor(i=0, this.s[i], i++) end\n"
"\t\n"
"\treturn i;\n"
"end\n"
"\n"
"\n"
"\n"
"method codegen cgstr:print():\n"
"\t__builtin_puts(this.s);\n"
"end\n"
"\n"
"method codegen cgstr:start():\n"
"\tthis.s = cast(char*)0;\n"
"end\n"
"\n"
"\n"
"\n"
"method codegen cgstr:free():\n"
"\t__builtin_free(this.s);\n"
"\tthis.s = cast(char*)0;\n"
"end\n"
"\n"
"method codegen pure cgstr:prefixed(cgstr o)->u8: //is THIS prefixed by o?\n"
"\tint i\n"
"\tif(o:isempty()) return 1; end //yes, we are prefixed by the null string.\n"
"\t\n"
"\tif(this:isempty()) return 0; end //we are not prefixed by a non-empty string because we are empty.\n"
"\t\n"
"\tfor(i = 0,o.s[i] neq 0,i++)\n"
"\t\tif(this.s[i] neq o.s[i]) //notice that this actually handles this.s[i] == 0....\n"
"\t\t\treturn 0;\n"
"\t\tend\n"
"\tend\n"
"\t\n"
"\t//we are prefixed by this string because we reached the end of it!\n"
"\treturn 1;\n"
"end\n"
"\n"
"method codegen pure cgstr:postfixed(cgstr o)->u8: //is THIS postfixed by o?\n"
"\tsqword i\n"
"\tcgstr h\n"
"\tsqword tlen //I'm doing this over and over again... Note to self: automate the process of creating tlen and olen...\n"
"\tsqword olen\n"
"\t\n"
"\tif(o:isempty()) return 1; end //yes, we are postfixed by the null string.\n"
"\tif(this:isempty()) return 0; end //we are not postfixed by a non-empty string because we are empty.\n"
"\ttlen = this:len();\n"
"\tolen = o:len();\n"
"\tif(tlen < olen) return 0; end //we cannot be postfixed if we are shorter...\n"
"\th.s = this.s + (tlen - olen); //skip the first part of the string\n"
"\n"
"\treturn h:prefixed(o);\n"
"end\n"
"\n"
"method codegen cgstr:invert():\n"
"\tuqword e;\n"
"\tuqword i;\n"
"\ti = 0;\n"
"\te = this:len()-1;\n"
"\tfor(0, i < e, i++ | e--)\n"
"\t\tchar f\n"
"\t\tf = this.s[i];\n"
"\t\tthis.s[i] = this.s[e];\n"
"\t\tthis.s[e] = f;\n"
"\tend\n"
"end\n"
"\n"
"fn codegen pure cgislower(char a)->u8:\n"
"\tif(a <= 'z')\n"
"\t\tif(a >= 'a')\n"
"\t\t\treturn 1;\n"
"\t\tend\n"
"\tend\n"
"\treturn 0;\n"
"end\n"
"\n"
"fn codegen pure cgisupper(char a)->u8:\n"
"\tif(a <= 'Z')\n"
"\t\tif(a >= 'A')\n"
"\t\t\treturn 1;\n"
"\t\tend\n"
"\tend\n"
"\treturn 0;\n"
"end\n"
"\n"
"fn codegen pure cgtoupper(char a)->char:\n"
"\tu8 diff1\n"
"\tu8 diff2\n"
"\tu8 isl\n"
"\tisl = cgislower(a);\n"
"\tdiff1 = isl * 'a';\n"
"\tdiff2 = isl * 'A';\n"
"\ta = a - diff1;\n"
"\ta = a + diff2;\n"
"\treturn a;\n"
"end\n"
"\n"
"fn codegen pure cgtolower(char a)->char:\n"
"\tu8 diff1\n"
"\tu8 diff2\n"
"\tu8 ish\n"
"\tish = cgisupper(a);\n"
"\tdiff1 = ish * 'A';\n"
"\tdiff2 = ish * 'a';\n"
"\ta = a - diff1;\n"
"\ta = a + diff2;\n"
"\treturn a;\n"
"end\n"
"\n"
"\n"
"method codegen cgstr:transform(char* input_fun):\n"
"\tuqword i\n"
"\tuqword tlen\n"
"\ttlen = this:len();\n"
"\tfor(i = 0, i < tlen, i++)\n"
"\t\tthis.s[i] = callfnptr[cgtoupper](input_fun)(this.s[i]);\n"
"\tend\n"
"\treturn;\n"
"end\n"
"\n"
"method codegen cgstr:toupper():\n"
"\tuqword i\n"
"\tuqword tlen\n"
"\ttlen = this:len();\n"
"\tfor(i = 0, i < tlen, i++)\n"
"\t\tthis.s[i] = cgtoupper(this.s[i]);\n"
"\tend\n"
"end\n"
"\n"
"method codegen cgstr:tolower():\n"
"\tuqword i\n"
"\tuqword tlen\n"
"\ttlen = this:len();\n"
"\tfor(i = 0, i < tlen, i++)\n"
"\t\tthis.s[i] = cgtolower(this.s[i]);\n"
"\tend\n"
"end\n"
"\n"
"method codegen pure cgstr:compare(cgstr o)->i16: //- for lt, 0 for eq, + for gt\n"
"\tuqword i\n"
"\tuqword tlen\n"
"\tuqword olen\n"
"\ttlen = this:len();\n"
"\tolen = o:len();\n"
"\tif(this.s == o.s) return 0; end//they are the same string. Conveniently, this also tests for the null case.\n"
"\t\n"
"\tfor(i = 0, 1, i++)\n"
"\t\tif(this.s[i] == 0)\n"
"\t\t\tif(o.s[i] == 0)\n"
"\t\t\t\treturn 0;;; //equals!\n"
"\t\t\tend\n"
"\t\tend\n"
"\t\tif(this.s[i] != o.s[i])\n"
"\t\t\treturn cast(i16)(cast(u16)this.s[i] - cast(u16)o.s[i]);\n"
"\t\tend\n"
"\tend\n"
"\n"
"\treturn 0;\n"
"end\n"
"\n"
"method codegen pure cgstr:find(cgstr o)->i64:\n"
"\tu64 tlen \n"
"\tu64 olen\n"
"\tu64 i\n"
"\n"
"\tif(o:isempty()) return 0; end     //we can find the empty string in ourselves.\n"
"\tif(this:isempty()) return -1; end //we cannot find anything in ourselves because we are empty.\n"
"\n"
"\ttlen = this:len(); olen = o:len();\n"
"\tif(olen > tlen) return -1; end    //we cannot find a longer string than ourselves in ourself.\n"
"\n"
"\n"
"\tfor(i = 0, tlen >= olen, i++ | tlen--)\n"
"\t\tcgstr q\n"
"\t\tq.s = this.s + i;\n"
"\t\tif(q:prefixed(o))\n"
"\t\t\treturn i;\n"
"\t\tend\n"
"\tend\n"
"\n"
"\t//cannot find it!\n"
"\treturn -1;\n"
"end\n"
"\n"
"method codegen cgstr:add(cgstr* o):\n"
"\t\n"
"\tchar* s_new\n"
"\tu64 tlen\n"
"\tu64 olen\n"
"\ttlen = this:len();\n"
"\tolen = o:len();\n"
"\n"
"\t/*\n"
"\t\t__builtin_puts(\"I am:\");\n"
"\t\t__builtin_puts(this.s);\n"
"\t\t__builtin_puts(\"o is:\");\n"
"\t\t__builtin_puts(o.s);\n"
"\t\t__builtin_puts(\"______________\");\n"
"\t*/\n"
"\t\n"
"\ts_new = __builtin_malloc(tlen + olen + 1);\n"
"\t\n"
"\tif(tlen)\n"
"\t\t__builtin_memcpy(s_new, this.s, tlen);\n"
"\tend\n"
"\tif(olen)\n"
"\t\t__builtin_memcpy(s_new + tlen, o.s, olen);\n"
"\tend\n"
"\t\n"
"\ts_new[tlen+olen] = 0;\n"
"\tthis:free();\n"
"\tthis.s = s_new;\n"
"end\n"
"\n"
"method codegen cgstr:addstr(char* s):\n"
"    cgstr o\n"
"    o.s = s;\n"
"    this:add(o);\n"
"end\n"
"\n"
"//predeclaration being used?!?!\n"
"method predecl codegen cgstr:fromstr(char* s);\n"
"\n"
"method codegen cgstr:fromcgstr(cgstr o):\n"
"\tthis:fromstr(o.s);\n"
"end\n"
"\n"
"method codegen cgstr:dupe()->cgstr*:\n"
"    cgstr q;\n"
"    q:fromcgstr(this);\n"
"    return q;\n"
"end\n"
"\n"
"method codegen cgstr:fromstr(char* s):\n"
"\tcgstr q\n"
"\tu64 l\n"
"\t\n"
"\tq.s = s;\n"
"\tl = q:len();\n"
"\tthis.s = __builtin_malloc(l+1);\n"
"\t__builtin_memcpy(this.s, s, l+1);\n"
"\t//this.s[l] = 0; //this was done automatically above...\n"
"\treturn;\n"
"end\n"
"\n"
"class cgtype\n"
"    noexport\n"
"\tu64 basetype\n"
"\tu64 pointerlevel\n"
"\tu64 arraylen\n"
"\tu64 structid\n"
"\tu64 is_lvalue\n"
"\n"
"\tu64 funcid\n"
"\tu64 is_function\n"
"\n"
"\tchar* membername\n"
"end\n"
"\n"
"class cgtypedecl\n"
"    noexport\n"
"\tchar* name\n"
"\tcgtype* members\n"
"\tu64 nmembers\n"
"\tu64 is_incomplete\n"
"\tu64 is_noexport\n"
"\tu64 is_union\n"
"\tu64 algn\n"
"end\n"
"\n"
"class cgsymdecl\n"
"    noexport\n"
"\tcgtype t\n"
"\tchar* name\n"
"\tcgtype*[CG_MAX_FARGS] fargs\n"
"\tu64 nargs\n"
"\tu8* fbody\n"
"\tu8* cdata\n"
"\tu64 cdata_sz\n"
"\tu64 is_pub\n"
"\tu64 is_incomplete\n"
"\tu64 is_codegen\n"
"\tu64 is_impure\n"
"\tu64 is_pure\n"
"\tu64 is_inline\n"
"\tu64 is_atomic\n"
"\tu64 is_volatile\n"
"\tu64 is_impure_globals_or_asm\n"
"\tu64 is_impure_uses_incomplete_symbols\n"
"    u64 is_data\n"
"    u64 is_noexport\n"
"end\n"
"\n"
"class cgscope\n"
"    noexport\n"
"\tcgsymdecl* syms\n"
"\tu64 nsyms\n"
"\tu8* stmts\n"
"\tu64 nstmts\n"
"\tu64 is_fbody\n"
"\tu64 is_loopbody\n"
"\tu64 walker_point\n"
"\tu64 stopped_at_scope1\n"
"end\n"
"\n"
"class cgstmt\n"
"    noexport\n"
"\tcgscope* whereami\n"
"\tcgscope* myscope\n"
"\tu64 kind\n"
"\tu8*[3] expressions\n"
"\tu64 nexpressions\n"
"\tcgstmt* referenced_loop\n"
"\tu64 symid\n"
"\tchar* referenced_label_name\n"
"\tchar** switch_label_list\n"
"\tu64* switch_label_indices\n"
"\tu64 switch_nlabels\n"
"\ti64 goto_scopediff\n"
"\ti64 goto_vardiff\n"
"\ti64 goto_where_in_scope\n"
"\tu64 linenum\n"
"\tu64 colnum\n"
"\tchar* filename\n"
"end\n"
"\n"
"class cgexpr_node\n"
"    noexport\n"
"\tcgtype t\n"
"\tu64 kind\n"
"\tdouble fdata\n"
"\tu64 idata\n"
"\tcgexpr_node*[CG_MAX_FARGS] subnodes\n"
"\tu64 symid\n"
"\tu64 fnptr_nargs\n"
"\tu64 constint_propagator\n"
"\tchar* symname\n"
"\tchar* method_name\n"
"\tu64 is_global_variable\n"
"\tu64 is_function\n"
"\tu64 is_local_variable\n"
"\tu64 is_implied\n"
"\tu64 was_struct_var\n"
"\tcgtype type_to_get_size_of\n"
"end\n"
"\n"
"class cgtypedecl_oop_metadata\n"
"    noexport\n"
"    i64 ctor_id\n"
"    i64 dtor_id\n"
"    i64 have_checked\n"
"end\n"
"\n"
"\n"
"class cgast\n"
"    noexport\n"
"\tcgtypedecl** type_table\n"
"\tcgsymdecl*** symbol_table\n"
"\tcgtypedecl_oop_metadata** oop_metadata;\n"
"\tcgscope*** scopestack\n"
"\tcgstmt*** loopstack\n"
"\t\n"
"\tu64* active_function\n"
"\tu64* ntypedecls\n"
"\tu64* nsymbols\n"
"\tu64* nscopes\n"
"\tu64* nloops\n"
"    u64 target_word\n"
"\tu64 signed_target_word\n"
"\tu64 target_max_float\n"
"end\n"
"\n"
"class cg_parser_cache noexport\n"
"    u64 active_function\n"
"    u64 nscopes\n"
"    u64 nloops\n"
"    cgscope** scopestack\n"
"    cgstmt** loopstack\n"
"end\n"
"\n"
"method codegen cg_parser_cache.save():\n"
"    cgast* ast = cast(cgast*)__builtin_get_ast();\n"
"    this.active_function = ast.active_function[0];\n"
"    this.nscopes = ast.nscopes[0];\n"
"    this.nloops = ast.nloops[0];\n"
"    this.scopestack = ast.scopestack[0];\n"
"    this.loopstack = ast.loopstack[0];\n"
"    \n"
"    ast.nscopes[0] = 0;\n"
"    ast.nloops[0] = 0;\n"
"    ast.scopestack[0] = 0;\n"
"    ast.loopstack[0] = 0;\n"
"    ast.active_function[0] = -1;\n"
"    //__builtin_puts(\"Executed a save!\");\n"
"end\n"
"\n"
"method codegen cg_parser_cache.load():\n"
"    cgast* ast = cast(cgast*)__builtin_get_ast();\n"
"    if(ast.scopestack[0] != 0)\n"
"        __builtin_free((u8*)ast.scopestack[0]);\n"
"    end\n"
"    if(ast.loopstack[0] != 0)\n"
"        __builtin_free((u8*)ast.loopstack[0]);\n"
"    end\n"
"    ast.nscopes[0] = this.nscopes;\n"
"    ast.nloops[0] = this.nloops;\n"
"    ast.scopestack[0] = this.scopestack;\n"
"    ast.loopstack[0] = this.loopstack;\n"
"    ast.active_function[0] = this.active_function;\n"
"    //__builtin_puts(\"Executed a load!\");\n"
"end\n"
"\n"
"fn codegen parsehook_global():\n"
"    cg_parser_cache pcache\n"
"    pcache.save();\n"
"    __builtin_parse_global();\n"
"    pcache.load();\n"
"end\n"
"\n"
"\n"
"class cgstrll\n"
"    noexport\n"
"\tchar* text\n"
"\tu64 id\n"
"\tu64 linenum\n"
"\tu64 colnum\n"
"\tchar* filename\n"
"\tu8* d //data, but data is a keyword in seabass.... I \n"
"\t//probably should have thought of that, huh?\n"
"\tcgstrll* right\n"
"end\n"
"\n"
"\n"
"fn codegen parsehook_globalscope():\n"
"    cgstrll* pp\n"
"    cg_parser_cache pcache\n"
"    pcache.save();\n"
"    while(1)\n"
"        pp = (cgstrll*)__builtin_peek();\n"
"        if(pp == 0) break end\n"
"        if(\n"
"            pp.d == CG_TOK_KEYWORD &&\n"
"            pp.text streq \"end\"\n"
"        )\n"
"            __builtin_consume();\n"
"            break; \n"
"        end\n"
"        __builtin_parse_global();\n"
"    end\n"
"    pcache.load();\n"
"end\n"
"\n"
"\n"
"method codegen cgstrll.dupe()->cgstrll*:\n"
"    /*\n"
"    \tcgstrll* retval\n"
"    \tretval = cast(cgstrll*)__builtin_malloc(sizeof(cgstrll));\n"
"    \tretval := this;\n"
"    \tif(cast(u64)this.text)\n"
"    \t\tretval.text = __builtin_strdup(this.text);\n"
"    \tend\n"
"    \tretval.right = cast(cgstrll*)0;\n"
"    \treturn retval;\n"
"\t*/\n"
"\treturn cast(cgstrll*)__builtin_strll_dupe(cast(char*)this);\n"
"end\n"
"\n"
"method codegen cgstrll.dupell()->cgstrll*:\n"
"\t/*\n"
"    \tcgstrll* retval\n"
"    \tcgstrll* rwalk\n"
"\n"
"    \tretval = this:dupe();\n"
"    \tthis = this.right;\n"
"    \trwalk = retval;\n"
"    \tfor(0, this != cast(cgstrll*)0, this = this.right)\n"
"    \t\trwalk.right = this:dupe();\n"
"    \t\trwalk = rwalk.right;\n"
"    \tend\n"
"    \treturn retval;\n"
"\t*/\n"
"\treturn cast(cgstrll*)__builtin_strll_dupell(cast(char*)this);\n"
"end\n"
"\n"
"\n"
"/*\n"
"    TODO: Implement a system for converting cgstrll's\n"
"    back into strings which can be passed into cg_qtok.\n"
"*/\n"
"\n"
"method codegen cgstrll:to_cstr()->char*:\n"
"    if(this.d == CG_TOK_STRING)\n"
"        //we need to STRINGIFY the string!\n"
"        cgstr p\n"
"        cgstr backslash\n"
"        cgstr quote\n"
"        cgstr f\n"
"        backslash.s = \"\\\\\";\n"
"        quote.s = \"\\\"\";\n"
"        p.fromstr(quote.s);\n"
"        p.add(quote);\n"
"        u64 len\n"
"        char* text\n"
"        text = this.text;\n"
"        for(0, text[0], text++)\n"
"            if(text[0] == '\\n')\n"
"                p:add(backslash);\n"
"                f.s = \"n\";p:add(f);\n"
"            elif(text[0] == '\\a')\n"
"                p:add(backslash);\n"
"                f.s = \"a\";p:add(f);\n"
"            elif(text[0] == '\\\"')\n"
"                p:add(backslash);\n"
"                f.s = \"\\\"\";p:add(f);\n"
"            elif(text[0] == '\\b')\n"
"                p:add(backslash);\n"
"                f.s = \"b\";p:add(f);\n"
"            elif(text[0] == '\\f')\n"
"                p:add(backslash);\n"
"                f.s = \"f\";p:add(f);\n"
"            elif(text[0] == '\\e')\n"
"                p:add(backslash);\n"
"                f.s = \"e\";p:add(f);            \n"
"            elif(text[0] == '\\\\')\n"
"                p:add(backslash);\n"
"                p:add(backslash);\n"
"            elif(text[0] == '\\r')\n"
"                p:add(backslash);\n"
"                f.s = \"r\";p:add(f);\n"
"            elif(text[0] == '\\t')\n"
"                p:add(backslash);\n"
"                f.s = \"t\";p:add(f);\n"
"            elif(text[0] == '\\v')\n"
"                p:add(backslash);\n"
"                f.s = \"v\";p:add(f);\n"
"            else\n"
"                char[2] buf\n"
"                buf[0] = text[0];\n"
"                buf[1] = 0;\n"
"                f.s = buf;p:add(f);\n"
"            end\n"
"        end\n"
"        p:add(quote);\n"
"        p:add(quote);\n"
"        return p.s;\n"
"    end\n"
"    if(1)\n"
"        cgstr retme\n"
"        cgstr quote\n"
"        cgstr temp\n"
"        quote.s = \"\\\"\";\n"
"        if(this.d == CG_TOK_OBRACK)\n"
"            retme:fromstr(quote.s);\n"
"            temp.s = \"[\";\n"
"            retme:add(temp);\n"
"            retme:add(quote);\n"
"            return retme.s;\n"
"        end    \n"
"        if(this.d == CG_TOK_CBRACK)\n"
"            retme:fromstr(quote.s);\n"
"            temp.s = \"]\";\n"
"            retme:add(temp);\n"
"            retme:add(quote);\n"
"            return retme.s;\n"
"        end  \n"
"        if(this.d == CG_TOK_OPAREN)\n"
"            retme:fromstr(quote.s);\n"
"            temp.s = \"(\";\n"
"            retme:add(temp);\n"
"            retme:add(quote);\n"
"            return retme.s;\n"
"        end    \n"
"        if(this.d == CG_TOK_CPAREN)\n"
"            retme:fromstr(quote.s);\n"
"            temp.s = \")\";\n"
"            retme:add(temp);\n"
"            retme:add(quote);\n"
"            return retme.s;\n"
"        end    \n"
"        if(this.d == CG_TOK_OCB)\n"
"            retme:fromstr(quote.s);\n"
"            temp.s = \"{\";\n"
"            retme:add(temp);\n"
"            retme:add(quote);\n"
"            return retme.s;\n"
"        end    \n"
"        if(this.d == CG_TOK_CCB)\n"
"            retme:fromstr(quote.s);\n"
"            temp.s = \"}\";\n"
"            retme:add(temp);\n"
"            retme:add(quote);\n"
"            return retme.s;\n"
"        end\n"
"        if(this.d == CG_TOK_SEMIC)\n"
"            retme:fromstr(quote.s);\n"
"            temp.s = \";\";\n"
"            retme:add(temp);\n"
"            retme:add(quote);\n"
"            return retme.s;\n"
"        end    \n"
"        if(this.d == CG_TOK_COMMA)\n"
"            retme:fromstr(quote.s);\n"
"            temp.s = \",\";\n"
"            retme:add(temp);\n"
"            retme:add(quote);\n"
"            return retme.s;\n"
"        end\n"
"    end\n"
"    if(this.d != CG_TOK_STRING)\n"
"        if(this.text != 0)\n"
"            //just wrap in quotes!\n"
"            cgstr quote\n"
"            cgstr b\n"
"            cgstr a\n"
"            quote.s = \"\\\"\";\n"
"            a.s = this.text;\n"
"            b:fromstr(quote.s);\n"
"            b:add(a);\n"
"            b:add(quote);\n"
"            return b.s;\n"
"        end\n"
"    end\n"
"    char* retval\n"
"    retval = 0;\n"
"    return retval;\n"
"end\n"
"\n"
"\n"
"method codegen cgstrll:debug_print():\n"
"\t:top\n"
"\tif(this == 0)\n"
"\t\treturn;\n"
"\tend\n"
"\tif(this.d == CG_TOK_STRING)\n"
"\t    __builtin_puts(\"~~~string:\");\n"
"\t\t__builtin_puts(this.text);\n"
"\t    __builtin_puts(\"~~~\");\n"
"\telif(cast(uptr)this.text)\n"
"\t\t__builtin_puts(this.text);\n"
"\telif(this.d == CG_TOK_OBRACK)\n"
"\t\t__builtin_puts(\"[\");\n"
"\telif(this.d == CG_TOK_CBRACK)\n"
"\t\t__builtin_puts(\"]\");\n"
"\telif(this.d == CG_TOK_OPAREN)\n"
"\t\t__builtin_puts(\"(\");\n"
"\telif(this.d == CG_TOK_CPAREN)\n"
"\t\t__builtin_puts(\")\");\n"
"\telif(this.d == CG_TOK_OCB)\n"
"\t\t__builtin_puts(\"{\");\n"
"\telif(this.d == CG_TOK_CCB)\n"
"\t\t__builtin_puts(\"}\");\n"
"\telif(this.d == CG_TOK_SEMIC)\n"
"\t\t__builtin_puts(\";\");\n"
"\telif(this.d == CG_TOK_COMMA)\n"
"\t\t__builtin_puts(\",\");\n"
"\tend\n"
"\tthis = this.right;\n"
"\tgoto top\n"
"end\n"
"\n"
"\n"
"method codegen cgstrll:push_end(cgstrll other):\n"
"\twhile(this.right != cast(cgstrll*)0)\n"
"\t\tthis = this.right;\n"
"\tend\n"
"\tthis.right = other;\n"
"\treturn;\n"
"end\n"
"\n"
"fn codegen cgtok_push_stream(cgstrll pushme):\n"
"\tcgstrll** n\n"
"\tcgstrll* pretender\n"
"\n"
"\tn  = cast(cgstrll**)__builtin_getnext();\n"
"\tpretender = pushme;\n"
"\twhile(pretender.right  != cast(cgstrll*)0)\n"
"\t\tpretender = pretender.right;\n"
"\tend\n"
"\tpretender.right = n[0];\n"
"\tn[0] = pushme; //set next pointer.\n"
"end\n"
"\n"
"//frees the entire list including the root node.\n"
"method codegen cgstrll:freelist():\n"
"\tcgstrll* r\n"
"\twhile(1)\n"
"\t\tif(this == 0)\n"
"\t\t\treturn;\n"
"\t\tend\n"
"\t\t\n"
"\t\tr = this.right;\n"
"\t\tif(this.text != 0)\n"
"\t\t\t__builtin_free(this.text);\n"
"\t\tend\n"
"\t\t__builtin_free(cast(u8*)this);\n"
"\t\tthis = r;\n"
"\tend\n"
"end\n"
"\n"
"method codegen cgstrll:dupelen(u64 len)->cgstrll*:\n"
"\tcgstrll* retval\n"
"\tcgstrll* current\n"
"\tcgstrll* tt\n"
"\ttt = this;\n"
"\n"
"\tretval = cast(cgstrll*)0;\n"
"\t//return null if they asked for nothing...\n"
"\tif(len == 0) \n"
"\t\treturn retval; \n"
"\tend\n"
"\t\n"
"\t\n"
"\tretval = tt:dupe();//duplicate ourselves.\n"
"\t\n"
"\tlen--; \t\t\t     //subtract from len!\n"
"\tcurrent = retval;    //set up current.\n"
"\ttt = tt.right;   //traverse right\n"
"\n"
"\twhile(len)\n"
"\t\tif(tt == cast(cgstrll*)0)\n"
"\t\t\treturn retval;\n"
"\t\tend\n"
"\t\tcurrent.right = tt:dupe();\n"
"\t\ttt = tt.right;\n"
"\t\tcurrent = current.right;\n"
"\t\tlen--;\n"
"\tend\n"
"\treturn retval;\n"
"end\n"
"\n"
"\n"
"fn codegen cg_getast()->cgast*:\n"
"    return (cgast*)__builtin_get_ast()\n"
"end\n"
"\n"
"//gets the value of the next variable.\n"
"fn codegen cg_peek()->cgstrll*:\n"
"\treturn cast(cgstrll*)__builtin_peek();\n"
"end\n"
"\n"
"//allows us to assign next.\n"
"fn codegen cg_getnext()->cgstrll**:\n"
"\treturn cast(cgstrll**)__builtin_getnext();\n"
"end\n"
"\n"
"\n"
"\n"
"fn codegen cg_token_dupe_skip(u64 len)->cgstrll*:\n"
"\tcgstrll* retval\n"
"\tcgstrll* walker\n"
"\tretval = cg_peek():dupelen(len);\n"
"\tfor(\n"
"\t\twalker = retval, \n"
"\t\twalker != cast(cgstrll*)0, \n"
"\t\twalker = walker.right\n"
"\t)\n"
"\t\t__builtin_consume();\n"
"\tend\n"
"\n"
"\treturn retval;\n"
"end\n"
"\n"
"//Assumes that you pass it a list \n"
"fn codegen cg_tok_arglist_remove_brackets(cgstrll* in)->cgstrll*:\n"
"\tcgstrll* retval\n"
"\tcgstrll* walker\n"
"    //check if this even is bracketed.\n"
"    \n"
"    if(in.d != CG_TOK_OBRACK)\n"
"        return in;\n"
"    end\n"
"    //check for the specific and unusual case that we have an empty arglist.\n"
"    if(in.right != 0)\n"
"        if(in.right.d == CG_TOK_CBRACK)\n"
"            in:freelist();\n"
"            return cast(cgstrll*)0;\n"
"        end\n"
"    end\n"
"\t//remove the first element\n"
"\tretval = in.right;\n"
"\tif(in.text != 0)\n"
"\t\t__builtin_free(in.text);\n"
"\t\tin.text = cast(char*)0;\n"
"\tend\n"
"\t__builtin_free(cast(u8*)in);\n"
"\tin = cast(cgstrll*)0;\n"
"\n"
"\t//Travel to the next-to-last element (so the last element is to our right.)\n"
"\twalker = retval;\n"
"\twhile(1)\n"
"\t    /*\n"
"\t\tif(walker.right == cast(cgstrll*)0) \n"
"\t\t\t__builtin_puts(\"ERROR! cg_tok_arglist_remove_brackets passed invalid arglist.\");\n"
"\t\t\t__builtin_puts(\"You may not pass an empty arglist!\");\n"
"\t\t\t__builtin_exit(1);\n"
"\t \tend\n"
"\t \t*/\n"
"\t\tif(walker.right.right == cast(cgstrll*)0)\n"
"\t\t\tbreak; \n"
"\t\tend\n"
"\t\twalker = walker.right;\n"
"\tend\n"
"\t\n"
"\t//pop walker's right.\n"
"\tif(walker.right.text != 0)\n"
"\t\t__builtin_free(walker.right.text);\n"
"\tend\n"
"\t__builtin_free(cast(u8*)walker.right);\n"
"\twalker.right = cast(cgstrll*)0;\n"
"\n"
"\treturn retval;\n"
"end\n"
"\n"
"method codegen cgstrll:cg_token_foldout_arglist()->cgstrll*:\n"
"\t//we already have a cgstrll linked list (this)\n"
"\t//we want to rip out the token list.\n"
"\t\n"
"\tcgstrll* retval\n"
"\tcgstrll* obrack_ptr\n"
"\tcgstrll* walker\n"
"\tretval = cast(cgstrll*)0;\n"
"\t\n"
"\t//if our right is null...\n"
"\t/*\n"
"\tif(this.right == 0)\n"
"\t\t__builtin_puts(\"CODEGEN TIME ERROR\");\n"
"\t\t__builtin_puts(\"cgstrll:cg_token_foldout_arglist() called on something\");\n"
"\t\t__builtin_puts(\"Which has null on its right!\");\n"
"\t\t__builtin_exit(1);\n"
"\tend\n"
"\t*/\n"
"\t\n"
"\t//invalid pass-in.\t\n"
"\tif(this.right.d != CG_TOK_OBRACK)\n"
"\t\t//get a single!\n"
"\t\tretval = this.right;\n"
"\t\tthis.right = this.right.right;\n"
"\t\tretval.right = 0;\n"
"\t\treturn retval;\n"
"\tend\n"
"\tobrack_ptr = this.right; \n"
"\tretval = obrack_ptr; //We want the opening bracket, actually.\n"
"\n"
"\n"
"\ti64 level;\n"
"\tlevel = 1; //skip obrack.\n"
"\twalker = obrack_ptr.right;\n"
"\tfor(\n"
"\t\t0,\n"
"\t\twalker != cast(cgstrll*)0, \n"
"\t\t0\n"
"\t)\n"
"\n"
"\t\tif(walker.d == CG_TOK_OBRACK) level++; \n"
"\t\telif(walker.d == CG_TOK_CBRACK) level--; end //walker will point to the closing bracket.\n"
"\t\t\n"
"\t\tif(level == 0) break; end\n"
"\t\twalker = walker.right;\n"
"\tend\n"
"\t/*\n"
"\tif(level != 0)\n"
"\t    __builtin_puts(\"CODEGEN TIME ERROR\");\n"
"\t    __builtin_puts(\"There are unmatched square brackets in the program.\");\n"
"\t    __builtin_puts(\"This caused me, cgstrll:cg_token_foldout_arglist, to fail.\");\n"
"\t    __builtin_puts(\"I'm returning Null. I Hope there's a more specific error message...\");\n"
"\t\t//error by returning zero.\n"
"\t\tretval = cast(cgstrll*)0;\n"
"\t\treturn retval;\n"
"\tend\n"
"\t*/\n"
"\tthis.right = walker.right; //close up the wound!\n"
"\twalker.right = cast(cgstrll*)0;\n"
"\treturn retval;\n"
"end\n"
"\n"
"\n"
"\n"
"fn codegen cg_token_grab_arglist(char* errtext)->cgstrll*:\n"
"\tcgstrll* retval\n"
"\tcgstrll* p\n"
"\tcgstrll* walker\n"
"\tcgstrll* owalker\n"
"\tp = cg_peek();\n"
"\t//if there are no arguments, return no arguments!\n"
"\t\n"
"\tif(cast(uptr)p == 0) \t\t\n"
"\t\t__builtin_puts(\"INTERNAL SYNTAX ERROR: Token Arglist is EMPTY!\");\n"
"\t\t__builtin_puts(errtext);\n"
"\t\t__builtin_exit(1);\n"
"\tend\n"
"\t\n"
"\t\n"
"\t//if the argument is a single, return it!\n"
"\tif(p.d != CG_TOK_OBRACK)\n"
"\t\tretval = p:dupe();\n"
"\t\t__builtin_consume();\n"
"\t\treturn retval;\n"
"\tend\n"
"\n"
"\t//the argument was an opening bracket...\n"
"\n"
"\t//Walk the token list until we reach the end or the matching closing square bracket\n"
"\n"
"\ti64 level;\n"
"\tlevel = 1;\n"
"\tretval = p:dupe();\n"
"\towalker = retval;\n"
"\t__builtin_consume();\n"
"\t\n"
"\twhile(1)\n"
"\t    p = cg_peek();\n"
"\t    if(p == 0) break\n"
"\t\telif(p.d == CG_TOK_OBRACK) level++; \n"
"\t\telif(p.d == CG_TOK_CBRACK) level--; end\n"
"\t\towalker.right = p:dupe();\n"
"\t\towalker = owalker.right;\n"
"\t\t__builtin_consume();\n"
"\t\tif(level == 0) break; end\n"
"\tend\n"
"\t\n"
"\t\n"
"\tif(level != 0)\n"
"\t\t__builtin_puts(\"INTERNAL SYNTAX ERROR: Token Arglist has mismatched square brackets!\");\n"
"\t\t__builtin_puts(errtext);\n"
"\t\t__builtin_exit(1);\n"
"\tend\n"
"\t\n"
"\treturn retval;\n"
"end\n"
"\n"
"//Traverse token list, grab args (single token or [nest of [token sets] to parse])\n"
"\n"
"\n"
"//build a token- from scratch!\n"
"//TODO is to automatically detect\n"
"//what the token should be.\n"
"fn codegen cg_buildtok(\n"
"\tchar* text,\n"
"\tu64 id,\n"
"\tu64 linenum,\n"
"\tu64 colnum,\n"
"\tchar* filename,\n"
"\tu8* d,\n"
"\tcgstrll* right\n"
")->cgstrll*:\n"
"\t//allocated on the heap just like everything else, of course.\n"
"\tcgstrll* p;\n"
"\tp = cast(cgstrll*)__builtin_malloc(sizeof(cgstrll));\n"
"\t\n"
"\tp.text = text;\n"
"\tp.id = id;\n"
"\tp.linenum = linenum;\n"
"\tp.colnum = colnum;\n"
"\tp.filename = filename;\n"
"\tp.d = d; //this is really our identification.\n"
"\tp.right = right;\n"
"\treturn p;\n"
"end\n"
"\n"
"//automatic token building.\n"
"fn codegen cg_autobuildtok(\n"
"\tchar* text,\n"
"\tint is_string,\n"
"\tint is_ident,\n"
"\tint is_int,\n"
"\tint is_float,\n"
"\tint is_keyw,\n"
"\tint is_operator\n"
")->cgstrll*:\n"
"\t//it will strdup a pointer for you for all these.\n"
"\tif(is_string)\n"
"\t\treturn cg_buildtok(\n"
"\t\t\t__builtin_strdup(text), 0,\n"
"\t\t\t0,0,\n"
"\t\t\t\"AUTO_GENERATED_NOT_REAL\",\n"
"\t\t\tCG_TOK_STRING,\n"
"\t\t\tcast(cgstrll*)0\n"
"\t\t);\n"
"\tend\t\n"
"\tif(is_ident)\n"
"\t\treturn cg_buildtok(\n"
"\t\t\t__builtin_strdup(text), 0,\n"
"\t\t\t0,0,\n"
"\t\t\t\"AUTO_GENERATED_NOT_REAL\",\n"
"\t\t\tCG_TOK_IDENT,\n"
"\t\t\tcast(cgstrll*)0\n"
"\t\t);\n"
"\tend\t\n"
"\tif(is_int)\n"
"\t\treturn cg_buildtok(\n"
"\t\t\t__builtin_strdup(text), 0,\n"
"\t\t\t0,0,\n"
"\t\t\t\"AUTO_GENERATED_NOT_REAL\",\n"
"\t\t\tCG_TOK_INT_CONST,\n"
"\t\t\tcast(cgstrll*)0\n"
"\t\t);\n"
"\tend\t\n"
"\tif(is_float)\n"
"\t\treturn cg_buildtok(\n"
"\t\t\t__builtin_strdup(text), 0,\n"
"\t\t\t0,0,\n"
"\t\t\t\"AUTO_GENERATED_NOT_REAL\",\n"
"\t\t\tCG_TOK_FLOAT_CONST,\n"
"\t\t\tcast(cgstrll*)0\n"
"\t\t);\n"
"\tend\n"
"\tif(is_keyw)\n"
"\t\treturn cg_buildtok(\n"
"\t\t\t__builtin_strdup(text), 0,\n"
"\t\t\t0,0,\n"
"\t\t\t\"AUTO_GENERATED_NOT_REAL\",\n"
"\t\t\tCG_TOK_KEYWORD,\n"
"\t\t\tcast(cgstrll*)0\n"
"\t\t);\n"
"\tend\n"
"\tif(is_operator)\n"
"\t\treturn cg_buildtok(\n"
"\t\t\t__builtin_strdup(text), 0,\n"
"\t\t\t0,0,\n"
"\t\t\t\"AUTO_GENERATED_NOT_REAL\",\n"
"\t\t\tCG_TOK_OPERATOR,\n"
"\t\t\tcast(cgstrll*)0\n"
"\t\t);\n"
"\tend\n"
"\t//it was not a string- detect simple cases.\n"
"\tif(text streq \"(\") \n"
"\t\treturn cg_buildtok(\n"
"\t\t\tcast(u8*)0, 0,\n"
"\t\t\t0,0,\n"
"\t\t\t\"AUTO_GENERATED_NOT_REAL\",\n"
"\t\t\tCG_TOK_OPAREN,\n"
"\t\t\tcast(cgstrll*)0\n"
"\t\t);\n"
"\tend\t\n"
"\tif(text streq \")\") \n"
"\t\treturn cg_buildtok(\n"
"\t\t\tcast(u8*)0, 0,\n"
"\t\t\t0,0,\n"
"\t\t\t\"AUTO_GENERATED_NOT_REAL\",\n"
"\t\t\tCG_TOK_CPAREN,\n"
"\t\t\tcast(cgstrll*)0\n"
"\t\t);\n"
"\tend\t\n"
"\tif(text streq \"{\") \n"
"\t\treturn cg_buildtok(\n"
"\t\t\tcast(u8*)0, 0,\n"
"\t\t\t0,0,\n"
"\t\t\t\"AUTO_GENERATED_NOT_REAL\",\n"
"\t\t\tCG_TOK_OCB,\n"
"\t\t\tcast(cgstrll*)0\n"
"\t\t);\n"
"\tend\t\n"
"\tif(text streq \"}\")\n"
"\t\treturn cg_buildtok(\n"
"\t\t\tcast(u8*)0, 0,\n"
"\t\t\t0,0,\n"
"\t\t\t\"AUTO_GENERATED_NOT_REAL\",\n"
"\t\t\tCG_TOK_CCB,\n"
"\t\t\tcast(cgstrll*)0\n"
"\t\t);\n"
"\tend\t\n"
"\tif(text streq \"[\")\n"
"\t\treturn cg_buildtok(\n"
"\t\t\tcast(u8*)0, 0,\n"
"\t\t\t0,0,\n"
"\t\t\t\"AUTO_GENERATED_NOT_REAL\",\n"
"\t\t\tCG_TOK_OBRACK,\n"
"\t\t\tcast(cgstrll*)0\n"
"\t\t);\n"
"\tend\t\n"
"\tif(text streq \"]\")\n"
"\t\treturn cg_buildtok(\n"
"\t\t\tcast(u8*)0, 0,\n"
"\t\t\t0,0,\n"
"\t\t\t\"AUTO_GENERATED_NOT_REAL\",\n"
"\t\t\tCG_TOK_CBRACK,\n"
"\t\t\tcast(cgstrll*)0\n"
"\t\t);\n"
"\tend\tif(text streq \";\")\n"
"\t\treturn cg_buildtok(\n"
"\t\t\tcast(u8*)0, 0,\n"
"\t\t\t0,0,\n"
"\t\t\t\"AUTO_GENERATED_NOT_REAL\",\n"
"\t\t\tCG_TOK_SEMIC,\n"
"\t\t\tcast(cgstrll*)0\n"
"\t\t);\n"
"\tend\t\n"
"\tif(text streq \",\")\n"
"\t\treturn cg_buildtok(\n"
"\t\t\tcast(u8*)0, 0,\n"
"\t\t\t0,0,\n"
"\t\t\t\"AUTO_GENERATED_NOT_REAL\",\n"
"\t\t\tCG_TOK_COMMA,\n"
"\t\t\tcast(cgstrll*)0\n"
"\t\t);\n"
"\tend\n"
"\tif(text streq \"#\")\n"
"\t\treturn cg_buildtok(\n"
"\t\t\tcast(u8*)0, 0,\n"
"\t\t\t0,0,\n"
"\t\t\t\"AUTO_GENERATED_NOT_REAL\",\n"
"\t\t\tCG_TOK_MACRO_OP,\n"
"\t\t\tcast(cgstrll*)0\n"
"\t\t);\n"
"\tend\n"
"\t//dump case\n"
"\tif(1)\n"
"\t\treturn cg_buildtok(\n"
"\t\t\ttext,\n"
"\t\t\t0,0,0,\n"
"\t\t\t\"AUTO_GENERATED_NOT_REAL\",\n"
"\t\t\tCG_TOK_UNKNOWN,\n"
"\t\t\tcast(cgstrll*)0\n"
"\t\t);\n"
"\tend\n"
"end\n"
"\n"
"fn codegen cg_is_operator(char* text)->u8:\n"
"\tif(text streq \"++\") return 1; end\n"
"\tif(text streq \"--\") return 1; end\n"
"\tif(text streq \":=\") return 1; end\n"
"\tif(text streq \":\") return 1; end\n"
"\tif(text streq \"<=\") return 1; end\n"
"\tif(text streq \"<\") return 1; end\n"
"\tif(text streq \">=\") return 1; end\n"
"\tif(text streq \">\") return 1; end\n"
"\tif(text streq \"!=\") return 1; end\n"
"\tif(text streq \"==\") return 1; end\n"
"\tif(text streq \"===\") return 1; end\n"
"\tif(text streq \"->\") return 1; end\n"
"\tif(text streq \".&\") return 1; end\n"
"\tif(text streq \"&\") return 1; end\n"
"\tif(text streq \"&&\") return 1; end\n"
"\tif(text streq \"|\") return 1; end\n"
"\tif(text streq \"||\") return 1; end\n"
"\tif(text streq \">>\") return 1; end\n"
"\tif(text streq \"<<\") return 1; end\n"
"\t\n"
"\tif(text streq \"~\") return 1; end\n"
"\tif(text streq \"!\") return 1; end\n"
"\tif(text streq \".\") return 1; end\n"
"\tif(text streq \"&\") return 1; end\n"
"\tif(text streq \"*\") return 1; end\n"
"\tif(text streq \"+\") return 1; end\n"
"\tif(text streq \"-\") return 1; end\n"
"\tif(text streq \"/\") return 1; end\n"
"\tif(text streq \"%\") return 1; end\n"
"\tif(text streq \"<\") return 1; end\n"
"\tif(text streq \">\") return 1; end\n"
"\tif(text streq \"^\") return 1; end\n"
"\tif(text streq \"|\") return 1; end\n"
"\tif(text streq \"?\") return 1; end\n"
"\tif(text streq \"=\") return 1; end\n"
"\tif(text streq \"@\") return 1; end\n"
"\n"
"\tif(text streq \"streq\") return 1; end\n"
"\tif(text streq \"strneq\") return 1; end\n"
"\t\n"
"\tif(text streq \"eq\") return 1; end\n"
"\tif(text streq \"neq\") return 1; end\n"
"\treturn 0;\n"
"end\n"
"\n"
"fn codegen cg_is_keyw(char* text)->u8:\n"
"\tif(text streq \"fn\") return 1; end\n"
"\tif(text streq \"function\") return 1; end\n"
"\tif(text streq \"func\") return 1; end\n"
"\tif(text streq \"procedure\") return 1; end\n"
"\tif(text streq \"proc\") return 1; end\n"
"\tif(text streq \"cast\") return 1; end\n"
"\n"
"\tif(text streq \"u8\") return 1; end\n"
"\tif(text streq \"char\") return 1; end\n"
"\tif(text streq \"byte\") return 1; end\n"
"\tif(text streq \"ubyte\") return 1; end\n"
"\tif(text streq \"uchar\") return 1; end\n"
"\n"
"\tif(text streq \"i8\") return 1; end\n"
"\tif(text streq \"schar\") return 1; end\n"
"\tif(text streq \"sbyte\") return 1; end\n"
"\n"
"\tif(text streq \"u16\") return 1; end\n"
"\tif(text streq \"ushort\") return 1; end\n"
"\t\n"
"\tif(text streq \"i16\") return 1; end\n"
"\tif(text streq \"short\") return 1; end\n"
"\tif(text streq \"sshort\") return 1; end\n"
"\n"
"\tif(text streq \"u32\") return 1; end\n"
"\tif(text streq \"uint\") return 1; end\n"
"\tif(text streq \"ulong\") return 1; end\n"
"\n"
"\tif(text streq \"i32\") return 1; end\n"
"\tif(text streq \"int\") return 1; end\n"
"\tif(text streq \"sint\") return 1; end\n"
"\tif(text streq \"long\") return 1; end\n"
"\tif(text streq \"slong\") return 1; end\n"
"\n"
"\tif(text streq \"u64\") return 1; end\n"
"\tif(text streq \"ullong\") return 1; end\n"
"\tif(text streq \"uqword\") return 1; end\n"
"\tif(text streq \"qword\") return 1; end\n"
"\tif(text streq \"uptr\") return 1; end\n"
"\n"
"\t\n"
"\tif(text streq \"i64\") return 1; end\n"
"\tif(text streq \"sllong\") return 1; end\n"
"\tif(text streq \"llong\") return 1; end\n"
"\tif(text streq \"sqword\") return 1; end\n"
"\t\n"
"\tif(text streq \"noexport\") return 1; end\n"
"\n"
"\tif(text streq \"f32\") return 1; end\n"
"\tif(text streq \"f64\") return 1; end\n"
"\tif(text streq \"float\") return 1; end\n"
"\tif(text streq \"double\") return 1; end\n"
"\n"
"\tif(text streq \"break\") return 1; end\n"
"\tif(text streq \"data\") return 1; end\n"
"\tif(text streq \"string\") return 1; end\n"
"\tif(text streq \"end\") return 1; end\n"
"\tif(text streq \"continue\") return 1; end\n"
"\tif(text streq \"if\") return 1; end\n"
"\tif(text streq \"else\") return 1; end\n"
"\tif(text streq \"while\") return 1; end\n"
"\n"
"\tif(text streq \"goto\") return 1; end\n"
"\tif(text streq \"jump\") return 1; end\n"
"\n"
"\tif(text streq \"return\") return 1; end\n"
"\tif(text streq \"tail\") return 1; end\n"
"\tif(text streq \"sizeof\") return 1; end\n"
"\tif(text streq \"static\") return 1; end\n"
"\tif(text streq \"pub\") return 1; end\n"
"\tif(text streq \"public\") return 1; end\n"
"\n"
"\tif(text streq \"struct\") return 1; end\n"
"\tif(text streq \"class\") return 1; end\n"
"\tif(text streq \"union\") return 1; end\n"
"\tif(text streq \"asm\") return 1; end\n"
"\tif(text streq \"method\") return 1; end\n"
"\tif(text streq \"predecl\") return 1; end\n"
"\tif(text streq \"codegen\") return 1; end\n"
"\n"
"\tif(text streq \"constexpri\") return 1; end\n"
"\tif(text streq \"constexprf\") return 1; end\n"
"\tif(text streq \"switch\") return 1; end\n"
"\tif(text streq \"for\") return 1; end\n"
"\n"
"\tif(text streq \"elif\") return 1; end\n"
"\tif(text streq \"elseif\") return 1; end\n"
"\n"
"\tif(text streq \"pure\") return 1; end\n"
"\tif(text streq \"inline\") return 1; end\n"
"\n"
"\tif(text streq \"atomic\") return 1; end\n"
"\tif(text streq \"volatile\") return 1; end\n"
"\n"
"\tif(text streq \"getfnptr\") return 1; end\n"
"\tif(text streq \"callfnptr\") return 1; end\n"
"\tif(text streq \"getglobalptr\") return 1; end\n"
"\n"
"\treturn 0;\n"
"end\n"
"\n"
"fn codegen cg_process_stringlit(char* text):\n"
"\t//remove starting and ending quotes.\n"
"\tcgstr q\n"
"\t\n"
"\t\n"
"\tcgstrcpy(text, text+1);//remove first character- a quote\n"
"\tq.s = (text); //move to cgstring\n"
"\tq.s[q:len()-1] = 0; //remove last character- a quote\n"
"\n"
"\t//for each character\n"
"\ti64 i\n"
"\ti64 len\n"
"\tlen = q:len();\n"
"\tfor(i = 0, i < len, i++)\n"
"\t\tif(q.s[i] == '\\\\')\n"
"\t\t\t//skip\n"
"\t\t\tif(q.s[i+1] == 0)\n"
"\t\t\t\tcontinue;\n"
"\t\t\telif(q.s[i+1] == 'a')\n"
"\t\t\t\tq.s[i] = '\\a';\n"
"\n"
"\t\t\t\tcgstrcpy(\n"
"\t\t\t\t\tq.s+i+1, \n"
"\t\t\t\t\tq.s+i+2\n"
"\t\t\t\t);\n"
"\t\t\t\tcontinue;\n"
"\t\t\telif(q.s[i+1] == 'b')\n"
"\t\t\t\tq.s[i] = '\\b';\n"
"\t\t\t\tcgstrcpy(q.s+i+1, q.s+i+2);\n"
"\t\t\t\tcontinue;\n"
"\t\t\telif(q.s[i+1] == 'e')\n"
"\t\t\t\tq.s[i] = '\\e';\n"
"\t\t\t\tcgstrcpy(q.s+i+1, q.s+i+2);\n"
"\t\t\t\tcontinue;\n"
"\t\t\telif(q.s[i+1] == 'f')\n"
"\t\t\t\tq.s[i] = '\\f';\n"
"\t\t\t\tcgstrcpy(q.s+i+1, q.s+i+2);\n"
"\t\t\t\tcontinue;\n"
"\n"
"\t\t\telif(q.s[i+1] == 'n')\n"
"\t\t\t\tq.s[i] = '\\n';\n"
"\t\t\t\tcgstrcpy(q.s+i+1, q.s+i+2);\n"
"\t\t\t\tcontinue;\n"
"\n"
"\t\t\telif(q.s[i+1] == 'r')\n"
"\t\t\t\tq.s[i] = '\\r';\n"
"\t\t\t\tcgstrcpy(q.s+i+1, q.s+i+2);\n"
"\t\t\t\tcontinue;\n"
"\t\t\telif(q.s[i+1] == 't')\n"
"\t\t\t\tq.s[i] = '\\t';\n"
"\t\t\t\tcgstrcpy(q.s+i+1, q.s+i+2);\n"
"\t\t\t\tcontinue;\n"
"\n"
"\t\t\telif(q.s[i+1] == 'v')\n"
"\t\t\t\tq.s[i] = '\\v';\n"
"\t\t\t\tcgstrcpy(q.s+i+1, q.s+i+2);\n"
"\t\t\t\tcontinue;\n"
"\t\t\telse\n"
"\t\t\t\t//literally that character...\n"
"\t\t\t\tq.s[i] = q.s[i+1];\n"
"\t\t\t\tcgstrcpy(q.s+i+1, q.s+i+2);\n"
"\t\t\t\tcontinue;\n"
"\t\t\tend //eof if-elif chain.\t\n"
"\t\tend //eof if\n"
"\tend //eof for loop\n"
"end //eof function\n"
"\n"
"/*\n"
"\tREMINDER\n"
"\tcg_autobuildtok(\n"
"\t\tchar* text,\n"
"\t\tint is_string,\n"
"\t\tint is_ident,\n"
"\t\tint is_int,\n"
"\t\tint is_float,\n"
"\t\tint is_keyw,\n"
"\t\tint is_operator\n"
"\t)\n"
"*/\n"
"\n"
"\n"
"fn codegen cg_qtok(\n"
"\tchar* text\n"
")->cgstrll*:\n"
"\tcgstrll* retval;\n"
"\ttext = __builtin_strdup(text); //avoid trouncing the original string.\n"
"\t//1. recognize strings.\n"
"\tif(text[0] == '\\\"')//this is a string.\n"
"\t\tcg_process_stringlit(text);\n"
"\t\tretval = cg_autobuildtok(\n"
"\t\t\ttext,\n"
"\t\t\t1,\n"
"\t\t\t0,\n"
"\t\t\t0,\n"
"\t\t\t0,\n"
"\t\t\t0,\n"
"\t\t\t0\n"
"\t\t);\n"
"\t\t__builtin_free(text);\n"
"\t\treturn retval;\n"
"\tend\n"
"\tif(text[0] == '\\'') //this is a character literal.\n"
"\t\tcgstr q\n"
"\t\tcg_process_stringlit(text);\n"
"\t\t//create a string for storage of a single 3 digit number.\n"
"\t\tq:fromstr(\"   \");\n"
"\t\t//convert character to text integer\n"
"\t\t__builtin_itoa(q.s, cast(u32)text[0]);\n"
"\t\t__builtin_free(text);\n"
"\t\tretval = cg_autobuildtok(\n"
"\t\t\tq.s,\n"
"\t\t\t0,\n"
"\t\t\t0,\n"
"\t\t\t1,\n"
"\t\t\t0,\n"
"\t\t\t0,\n"
"\t\t\t0\n"
"\t\t);\n"
"\t\tq:free();\n"
"\t\t//return the token.\n"
"\t\treturn retval;\n"
"\tend\n"
"\tif(cg_is_keyw(text))\n"
"\t\tretval = cg_autobuildtok(\n"
"\t\t\ttext,\n"
"\t\t\t0, //is_string\n"
"\t\t\t0, //is_ident\n"
"\t\t\t0, //is_int\n"
"\t\t\t0, //is_float\n"
"\t\t\t1, //is_keyw\n"
"\t\t\t0  //is_operator\n"
"\t\t);\n"
"\t\t__builtin_free(text);\n"
"\t\treturn retval;\n"
"\tend\n"
"\tif(cg_is_operator(text))\n"
"\t\tretval = cg_autobuildtok(\n"
"\t\t\ttext,\n"
"\t\t\t0, //is_string\n"
"\t\t\t0, //is_ident\n"
"\t\t\t0, //is_int\n"
"\t\t\t0, //is_float\n"
"\t\t\t0, //is_keyw\n"
"\t\t\t1  //is_operator\n"
"\t\t);\n"
"\t\t__builtin_free(text);\n"
"\t\treturn retval;\n"
"\tend\n"
"\n"
"\t\n"
"\t//does this match the prototype of an identifier?\n"
"\tcgstr qq;\n"
"\tqq.s = text;\n"
"\t\n"
"\tif(\n"
"\t\t(qq:len() > 0) &&\n"
"\t\t(\n"
"\t\t\tcgisalpha(text[0]) ||\n"
"\t\t\t(text[0] == '_')\n"
"\t\t)\n"
"\t)\n"
"\t\tretval = cg_autobuildtok(\n"
"\t\t\ttext,\n"
"\t\t\t0, //is_string\n"
"\t\t\t1, //is_ident\n"
"\t\t\t0, //is_int\n"
"\t\t\t0, //is_float\n"
"\t\t\t0, //is_keyw\n"
"\t\t\t0  //is_operator\n"
"\t\t);\n"
"\t\t__builtin_free(text);\n"
"\t\treturn retval;\n"
"\tend\n"
"\t\n"
"\t//int or float.\n"
"\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"\t//INT OR FLOAT DETECTOR\n"
"\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"\tif(cgisdigit(text[0]))\n"
"\t\t//detect hex\n"
"\t\tif(\n"
"\t\t\ttext[0] == 'x' ||\n"
"\t\t\ttext[0] == 'X'\n"
"\t\t)\n"
"\t\t\tgoto is_integer\n"
"\t\tend\n"
"\t\t//detect float\n"
"\t\tif(1)\n"
"\t\t\tcgstr tmp\n"
"\t\t\tcgstr findme\n"
"\t\t\ttmp.s = text;\n"
"\t\t\tfindme.s = \".\";\n"
"\t\t\tif(tmp:find(findme) != -1)\n"
"\t\t\t\tjump is_float\n"
"\t\t\tend\n"
"\t\t\t//contains an \"e\" portion: power of 10.\n"
"\t\t\tfindme.s = \"E\";\n"
"\t\t\tif(tmp:find(findme) != -1)\n"
"\t\t\t\tjump is_float\n"
"\t\t\tend\n"
"\t\t\tfindme.s = \"e\";\n"
"\t\t\tif(tmp:find(findme) != -1)\n"
"\t\t\t\tjump is_float\n"
"\t\t\tend\n"
"\t\tend\n"
"\t\t//it is an integer!\n"
"\t\tjump is_integer\n"
"\tend\n"
"\n"
"\t//This is something else. have autobuildtok figure it out.\n"
"\t//just send it and then free the text.\n"
"\tretval = cg_autobuildtok(\n"
"\t\ttext,\n"
"\t\t0, //is_string\n"
"\t\t0, //is_ident\n"
"\t\t0, //is_int\n"
"\t\t0, //is_float\n"
"\t\t0, //is_keyw\n"
"\t\t0  //is_operator\n"
"\t);\n"
"\tretval.text = cast(char*)0;\n"
"\t__builtin_free(text);\n"
"\treturn retval;\n"
"\n"
"\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"\t//POST_FUNCTION_PORTION\n"
"\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"\t:is_integer\n"
"\t\tretval = cg_autobuildtok(\n"
"\t\t\ttext,\n"
"\t\t\t0, //is_string\n"
"\t\t\t0, //is_ident\n"
"\t\t\t1, //is_int\n"
"\t\t\t0, //is_float\n"
"\t\t\t0, //is_keyw\n"
"\t\t\t0  //is_operator\n"
"\t\t);\n"
"\t\t__builtin_free(text);\n"
"\t\treturn retval;\n"
"\t:is_float\n"
"\t\tretval = cg_autobuildtok(\n"
"\t\t\ttext,\n"
"\t\t\t0, //is_string\n"
"\t\t\t0, //is_ident\n"
"\t\t\t0, //is_int\n"
"\t\t\t1, //is_float\n"
"\t\t\t0, //is_keyw\n"
"\t\t\t0  //is_operator\n"
"\t\t);\n"
"\t\t__builtin_free(text);\n"
"\t\treturn retval;\n"
"end //eof cg_qtok\n"
"\n"
"/*\n"
"\t\n"
"*/\n"
"\n"
"fn codegen cgast_struct_size_test():\n"
"\tif(sizeof(cgtype) != __builtin_struct_metadata(0))\n"
"\t\t__builtin_puts(\"fail: cgtype\");\n"
"\telse\n"
"\t\t__builtin_puts(\"pass: cgtype\");\n"
"\tend\n"
"\n"
"\tif(sizeof(cgtypedecl) != __builtin_struct_metadata(1))\n"
"\t\t__builtin_puts(\"fail: cgtypedecl\");\n"
"\telse\n"
"\t\t__builtin_puts(\"pass: cgtypedecl\");\n"
"\tend\n"
"\n"
"\tif(sizeof(cgsymdecl) != __builtin_struct_metadata(2))\n"
"\t\t__builtin_puts(\"fail: cgsymdecl\");\n"
"\telse\n"
"\t\t__builtin_puts(\"pass: cgsymdecl\");\n"
"\tend\n"
"\n"
"\tif(sizeof(cgscope) != __builtin_struct_metadata(3))\n"
"\t\t__builtin_puts(\"fail: cgscope\");\n"
"\telse\n"
"\t\t__builtin_puts(\"pass: cgscope\");\n"
"\tend\n"
"\n"
"\tif(sizeof(cgstmt) != __builtin_struct_metadata(4))\n"
"\t\t__builtin_puts(\"fail: cgstmt\");\n"
"\telse\n"
"\t\t__builtin_puts(\"pass: cgstmt\");\n"
"\tend\t\n"
"\tif(sizeof(cgexpr_node) != __builtin_struct_metadata(5))\n"
"\t\t__builtin_puts(\"fail: cgexpr_node\");\n"
"\telse\n"
"\t\t__builtin_puts(\"pass: cgexpr_node\");\n"
"\tend\t\n"
"\n"
"\tif(sizeof(cgast) != __builtin_struct_metadata(6))\n"
"\t\t__builtin_puts(\"fail: cgast\");\n"
"\telse\n"
"\t\t__builtin_puts(\"pass: cgast\");\n"
"\tend\t\n"
"\t\n"
"\tif(sizeof(cgtypedecl_oop_metadata) != __builtin_struct_metadata(7))\n"
"\t\t__builtin_puts(\"fail: cgtypedecl_oop_metadata\")\n"
"\telse\n"
"\t\t__builtin_puts(\"pass: cgtypedecl_oop_metadata\")\n"
"\tend\n"
"\t\n"
"end\n"
""
